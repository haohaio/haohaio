{"meta":{"title":"灏絯喔","subtitle":"努力学习，艰苦奋斗","description":"好记性不如烂笔头","author":"haohaio","url":"https://haohaio.github.io"},"pages":[{"title":"为何建站 && 为何写作","date":"2018-12-12T04:12:12.000Z","updated":"2018-12-15T11:56:25.307Z","comments":false,"path":"about/index.html","permalink":"https://haohaio.github.io/about/index.html","excerpt":"","text":"为何建站这个网站主要是为了在学习的过程中记一下笔记，深化一下记忆。当然大家浏览本网站时，我相信大家也可以学到一点东西。 为何写作目前在我看来，写作还是个比较花时间的活儿。但是在写作的过程中，对自己各方面的提升还是蛮大的，所以我会尽量坚持下去。 作为内容站，持续输出高质量的内容是件不太容易的事情，本站的任何文章，你可任意转载，但请保留原文链接。"},{"title":"QA - 帮助中心","date":"2018-12-12T04:12:12.000Z","updated":"2018-12-15T11:59:51.436Z","comments":true,"path":"help/index.html","permalink":"https://haohaio.github.io/help/index.html","excerpt":"","text":"Q: 为什么博客有时候打开速度很慢，一直在加载呢？ A: 评论组件使用的Disqus等资源的服务器在墙外，你懂的…(不懂问搜狗)。不过不影响文章阅读。 暂时更新这些，需要什么本文底部留言…"},{"title":"标签云","date":"2017-02-04T07:37:12.000Z","updated":"2018-12-16T02:38:49.205Z","comments":true,"path":"tags/index.html","permalink":"https://haohaio.github.io/tags/index.html","excerpt":"","text":""},{"title":"嘉宾推荐","date":"2018-12-12T04:12:12.000Z","updated":"2018-12-15T14:49:20.094Z","comments":false,"path":"links/index.html","permalink":"https://haohaio.github.io/links/index.html","excerpt":"","text":"以下摘录有趣、有意义、有影响力、有正能量的博客、资源 此处不做网址导航，因此不接受以SEO为目的的友链。排序不分那啥… JS大法系 阮一峰博客闲情写手腾讯AlloyTeam 苹果派 王巍（喵神）的博客Objc.ioSwifter 娱乐圈 VIMCodeTank 公众号 没有链接，请直接关注微信公众号：涔汐(zhangcenxi99)、小道消息、MacTalk等等"}],"posts":[{"title":"TypeScript 之 Enum","slug":"typescript-enum","date":"2019-07-31T03:23:48.000Z","updated":"2019-07-31T03:24:52.611Z","comments":true,"path":"front-end/typescript-enum-1564543428.html","link":"","permalink":"https://haohaio.github.io/front-end/typescript-enum-1564543428.html","excerpt":"","text":"TypeScript支持基于数字和字符串的枚举。 数字枚举// Direction.Up的值为 0, 其余的成员会从 0 开始递增enum Direction &#123; Up, Down, Left, Right&#125;// 从 1 开始递增enum Direction &#123; Up = 1, Down, Left, Right&#125; 枚举的使用我们可以通过枚举的属性来访问枚举成员 enum Result &#123; No, Yes&#125;function respond(recipient: string, message: Result): void &#123; // ...&#125;respond(\"Princess Caroline\", Result.Yes) 字符串枚举相对于数字枚举而言，字符串枚举的可读性更强，但字符串枚举没有自增长的行为。 enum Direction &#123; Up = \"UP\", Down = \"DOWN\", Left = \"LEFT\", Right = \"RIGHT\",&#125; 异构枚举（Heterogeneous enums）从技术的角度来说，枚举可以混合字符串和数字成员，但是一般也不会这么做。 enum BooleanLikeHeterogeneousEnum &#123; No = 0, Yes = \"YES\",&#125; 常量成员和计算成员常量成员枚举成员使用 常量枚举表达式 初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式： 一个枚举表达式字面量（主要是字符串字面量或数字字面量） 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的） 带括号的常量枚举表达式 一元运算符 +, -, ~其中之一应用在了常量枚举表达式 常量枚举表达式做为二元运算符 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^的操作对象。 若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错。 计算成员所有非常量成员情况的枚举成员被当作是计算成员。 enum FileAccess &#123; // 常量成员 None, Read = 1 &lt;&lt; 1, Write = 1 &lt;&lt; 2, ReadWrite = Read | Write, // 计算成员 G = \"123\".length&#125; const 枚举为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 const枚举。 const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right] 常量枚举在编辑阶段会被删除，在使用的地方会被内联进来，之所以可以这么做是因为，常量枚举不允许包含计算成员。可以看到编译后的代码是这样的： var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 常量枚举内包含计算成员时，会报错： const enum FileAccess &#123; None, Read = 1 &lt;&lt; 1, Write = 1 &lt;&lt; 2, ReadWrite = Read | Write, G = \"123\".length // Error: const enum member initializers can only contain literal values and other computed enum values.&#125; 再看下非 const 枚举编译后的代码： var Directions;(function (Directions) &#123; Directions[Directions[\"Up\"] = 0] = \"Up\"; Directions[Directions[\"Down\"] = 1] = \"Down\"; Directions[Directions[\"Left\"] = 2] = \"Left\"; Directions[Directions[\"Right\"] = 3] = \"Right\";&#125;)(Directions || (Directions = &#123;&#125;));var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://haohaio.github.io/tags/TypeScript/"}]},{"title":"TypeScript 之 Generics","slug":"typescript-generics","date":"2019-07-31T02:35:53.000Z","updated":"2019-07-31T02:36:55.270Z","comments":true,"path":"front-end/typescript-generics-1564540553.html","link":"","permalink":"https://haohaio.github.io/front-end/typescript-generics-1564540553.html","excerpt":"","text":"泛型变量我们可以在不知道函数参数类型的情况下，使用泛型来保证返回值的类型与传入参数的类型相同： // 为函数添加类型变量 T。T 帮助我们捕获用户传入的类型（比如：number），之后我们再次使用了 T 当做返回值类型。function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125; 我们使用泛型创建了泛型函数后，可以这样调用： // 传入所有的参数，包括类型参数。明确的指定了 T 是 string 类型let output = identity&lt;string&gt;(\"myString\"); 或者： // 利用了类型推论，编译器会根据传入的参数自动地帮助我们确定 T 的类型let output = identity(\"myString\"); 我们还可以把我们把泛型变量 T 当做类型的一部分使用： function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123; console.log(arg.length); // Array has a .length return arg;&#125; function loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123; console.log(arg.length); // Array has a .length return arg;&#125; 泛型接口我们可以使用接口来定义函数类型： interface GenericIdentityFn &#123; &lt;T&gt;(arg: T): T;&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: GenericIdentityFn = identity; 我们还可以把泛型参数当作整个接口的一个参数，这样我们就能清楚的知道使用的具体是哪个泛型类型： interface GenericIdentityFn&lt;T&gt; &#123; (arg: T): T;&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: GenericIdentityFn&lt;number&gt; = identity;myIdentity(123); // OKmyIdentity(\"123\"); // Error: 类型“\"123\"”的参数不能赋给类型“number”的参数 泛型类泛型类看上去与泛型接口差不多。 泛型类使用（ &lt;&gt;）括起泛型类型，跟在类名后面。 class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function (x, y) &#123; return x + y; &#125;; 可以看到，类中只能使用同一种类型。 泛型约束可以看到下面这个例子中：我们想访问 arg 的 length 属性，但是编译器并不能证明每种类型都有 length 属性，所以就报错了。 function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); // Error: T doesn't have .length return arg;&#125; 当我们想要限制函数去处理任意带有.length属性的所有类型。 我们需对传入的类型进行约束，要求传出的属性至少包含 length 这一属性。我们可以使用接口和 extends 关键字来实现约束： interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); // OK return arg;&#125;loggingIdentity(&#123; length: 3, value: \"123\" &#125;); // OK 使用类型参数进行约束声明一个类型参数，且它被另一个类型参数所约束： // 约束 K 是 T 的 keyfunction getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123; return obj[key];&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;getProperty(x, \"a\"); // OKgetProperty(x, \"m\"); // Error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://haohaio.github.io/tags/TypeScript/"}]},{"title":"TypeScript 之 Function","slug":"typescript-function","date":"2019-07-26T02:45:26.000Z","updated":"2019-07-26T03:39:45.538Z","comments":true,"path":"front-end/typescript-function-1564109126.html","link":"","permalink":"https://haohaio.github.io/front-end/typescript-function-1564109126.html","excerpt":"","text":"函数类型和 JavaScript 中的函数一样，我们可以用函数声明和函数表达式两种方式来定义函数。在 TypeScript 中，我们可以为函数定义类型（参数类型和返回值类型）。 function add(x: number, y: number): number &#123; return x + y;&#125;let myAdd = function(x: number, y: number): number &#123; return x + y; &#125;; 在使用函数表达式来定义函数时，我们还可以写出函数的完整类型： let myAdd: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123; return x + y; &#125;; 推断类型如果你在赋值语句的一边指定了类型但是另一边没有类型的话， TypeScript 编译器会自动识别出类型： // The parameters x and y have the type numberlet myAdd: (baseValue: number, increment: number) =&gt; number = function (x, y) &#123; return x + y; &#125;; 这叫做“按上下文归类”，是类型推论的一种。 它帮助我们更好地为程序指定类型。 函数参数在正常情况下，TypeScript 里的每个函数参数都是必须的。 这不是指不能传递 null 或 undefined 作为参数，而是说编译器检查用户是否为每个参数都传入了值。function buildName(firstName: string, lastName: string) &#123; return firstName + \" \" + lastName;&#125;let result1 = buildName(\"Bob\"); // Error: An argument for 'lastName' was not provided.let result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // Error: 应有 2 个参数，但获得 3 个。let result3 = buildName(\"Bob\", \"Adams\"); // OK 可选参数JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined。 在 TypeScript 里我们可以在参数名旁使用 ? 实现可选参数的功能。 function buildName(firstName: string, lastName?: string) &#123; if (lastName) &#123; return firstName + \" \" + lastName; &#125; else &#123; return firstName; &#125;&#125;let result1 = buildName(\"Bob\"); // OKlet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // Error: 应有 1-2 个参数，但获得 3 个。let result3 = buildName(\"Bob\", \"Adams\"); // OK 可选参数必须跟在必须参数后面。 如果上例我们只想让 firstName 是可选的，那么就必须调整它们的位置，把 firstName 放在后面。 默认参数在 TypeScript 里，我们也可以为参数提供一个默认值，当用户没有传递这个参数或传递的值是 undefined 时，这个参数的值就为默认值。它们叫做有默认初始化值的参数。 function buildName(firstName: string, lastName = \"Smith\") &#123; return firstName + \" \" + lastName;&#125;let result1 = buildName(\"Bob\"); // OK, returns \"Bob Smith\"let result2 = buildName(\"Bob\", undefined); // OK, also returns \"Bob Smith\"let result3 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // Error: 应有 1-2 个参数，但获得 3 个。let result4 = buildName(\"Bob\", \"Adams\"); // OK 剩余参数在JavaScript里，我们可以使用 arguments来访问所有传入的参数。在TypeScript里，当我们想同时操作多个参数，或者并不知道会有多少参数传递进来时，我们可以把所有参数收集到一个变量里： function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + \" \" + restOfName.join(\" \");&#125;let employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\"); 剩余参数会被当做个数不限的可选参数，可以一个都没有，同样也可以有任意个。 this在 JavaScript 里，this 的值在函数被调用的时候才会指定。在 TypeScript 中也一样。具体可参考 JavaScript 之 This 关于 –noImplicitThis，等之后涉及了在后续补充。 重载如下所示：重载的 pickCard 函数在调用的时候会进行正确的类型检查。查找重载列表时，JavaScript里的处理流程一样，是从上到下查找的，因此，在定义重载的时候，一定要把最精确的定义放在最前面。 function pickCard(x): any 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用 pickCard会产生错误。 let suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];function pickCard(x: &#123; suit: string; card: number; &#125;[]): number;function pickCard(x: number): &#123; suit: string; card: number; &#125;;function pickCard(x): any &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == \"number\") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [&#123; suit: \"diamonds\", card: 2 &#125;, &#123; suit: \"spades\", card: 10 &#125;, &#123; suit: \"hearts\", card: 4 &#125;];let pickedCard1 = myDeck[pickCard(myDeck)];alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);let pickedCard2 = pickCard(15);alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit);let pickedCard3 = pickCard(\"123\"); // Error: 类型“\"123\"”的参数不能赋给类型“number”的参数。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://haohaio.github.io/tags/TypeScript/"}]},{"title":"JavaScript 之 This","slug":"javascript-this","date":"2019-07-26T01:18:49.000Z","updated":"2019-07-26T02:28:45.964Z","comments":true,"path":"front-end/javascript-this-1564103929.html","link":"","permalink":"https://haohaio.github.io/front-end/javascript-this-1564103929.html","excerpt":"","text":"JavaScript 的 this 总是指向一个对象，而具体指向那个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 this 的指向大致可以分为以下4种： 作为对象的方法调用当函数作为对象的方法被调用时，this 指向该对象 var obj = &#123; a: 1, getA: function() &#123; console.log(this === obj); // 输出：true console.log(this.a); // 输出：1 &#125;&#125;obj.getA(); 作为普通函数调用当函数不作为对象的属性被调用时，即普通函数方式，this 总是指向全局对象。在浏览器的 JavaScript 里，这个全局对象是 window 对象。但需要注意的时，在严格模式下， this 为 undefined 而不是 window。 window.name = 'globalName';var getName = function() &#123; return this.name;&#125;console.log(getName()); // 输出：globalName 构造器调用通常情况下，构造器里的 this 就指向返回的这个对象。但当 new 调用构造器时，如果构造器显式地返回了一个object类型的对象，那么运行结果最终会返回这个对象，而不是我们之前期待的this。 var myClass = function() &#123; this.name = 'sven'; return &#123; name: 'anne' &#125;&#125;var obj = new myClass();console.log(obj.name); // 输出：anne Function.prototype.call 或 Function.prototype.apply 调用var obj1 = &#123; name: 'sven', getName: function() &#123; return this.name; &#125;&#125;var obj2 = &#123; name: 'anne'&#125;console.log(obj1.getName()); // 输出：svenconsole.log(obj1.getName.call(obj2)); // 输出：anne 丢失的 thiswindow.name = 'globalName';var myObject = &#123; name: 'sven', getName: function() &#123; return this.name; &#125;&#125;// 对象方法调用console.log(myObject.getName()); // 输出：sven// 定义了一个 getName 的函数，此时为普通函数调用，this 指向了 windowvar getName = myObject.getName;console.log(getName()); // 输出：globalName","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"JavaScript 之 this","slug":"JavaScript-之-this","permalink":"https://haohaio.github.io/tags/JavaScript-之-this/"}]},{"title":"TypeScript 之 Class","slug":"typescript-class","date":"2019-07-25T11:52:56.000Z","updated":"2019-07-25T12:06:34.873Z","comments":true,"path":"front-end/typescript-class-1564055576.html","link":"","permalink":"https://haohaio.github.io/front-end/typescript-class-1564055576.html","excerpt":"","text":"我们可以像在 Java 里一样，声明一个 Greeter 类，然后使用 new 来构造一个 Greeter 类的实例： class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return \"Hello, \" + this.greeting; &#125;&#125;let greeter = new Greeter(\"world\"); 继承和 Java 中一样，类之间是可以继承的。 class Animal &#123; move(distanceInMeters: number = 0) &#123; console.log(`Animal moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Dog extends Animal &#123; bark() &#123; console.log('Woof! Woof!'); &#125;&#125;const dog = new Dog();dog.bark();dog.move(10); 在 TypeScript 中，若派生类包含了一个构造函数，它必须调用 super()，它会执行基类的构造函数。而且，在构造函数里访问 this的属性之前，一定要调用 super()。 class Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 5) &#123; console.log(\"Slithering...\"); super.move(distanceInMeters); &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 45) &#123; console.log(\"Galloping...\"); super.move(distanceInMeters); &#125;&#125;let sam = new Snake(\"Sammy the Python\");let tom: Animal = new Horse(\"Tommy the Palomino\");sam.move();tom.move(34); 修饰符在TypeScript里，成员都默认为 public。 private当成员被标记成 private时，它就不能在声明它的类的外部访问。比如： class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;new Animal(\"Cat\").name; // Error: 属性“name”为私有属性，只能在类“Animal”中访问。 protectedprotected 修饰符与 private 修饰符的行为很相似，但有一点不同，protected 成员在派生类中仍然可以访问。例如： class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name) this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(\"Howard\", \"Sales\");console.log(howard.getElevatorPitch());console.log(howard.name); // Error readonlyclass Octopus &#123; readonly name: string; readonly numberOfLegs: number = 8; constructor(theName: string) &#123; this.name = theName; &#125;&#125;let dad = new Octopus(\"Man with the 8 strong legs\");dad.name = \"Man with the 3-piece suit\"; // Error: Cannot assign to 'name' because it is a read-only property. 参数属性参数属性可以方便地让我们在一个地方定义并初始化一个成员。 参数属性通过给构造函数参数前面添加一个访问限定符来声明。public、private、protected、readonly 都可以。 // 调用构造器方法时候，会定义并初始化一个 readonly 的 name 属性class Octopus &#123; readonly numberOfLegs: number = 8; constructor(readonly name: string) &#123; &#125;&#125; 存取器TypeScript支持通过getters/setters来截取对对象成员的访问。但与 Java 不同的是，添加了 getters/setters 方法后，我们还是使用 . 来存取这个属性 let passcode = \"secret passcode\";class Employee &#123; private _fullName: string; get fullName(): string &#123; return this._fullName; &#125; set fullName(newName: string) &#123; if (passcode &amp;&amp; passcode == \"secret passcode\") &#123; this._fullName = newName; &#125; else &#123; console.log(\"Error: Unauthorized update of employee!\"); &#125; &#125;&#125;let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) &#123; alert(employee.fullName);&#125; 静态属性class Grid &#123; static origin = &#123; x: 0, y: 0 &#125;; calculateDistanceFromOrigin(point: &#123; x: number; y: number; &#125;) &#123; let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; &#125; constructor(public scale: number) &#123; &#125;&#125;let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;));console.log(grid2.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;)); 抽象类abstract class Department &#123; constructor(public name: string) &#123; &#125; printName(): void &#123; console.log('Department name: ' + this.name); &#125; abstract printMeeting(): void; // 必须在派生类中实现&#125;class AccountingDepartment extends Department &#123; constructor() &#123; super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() &#125; printMeeting(): void &#123; console.log('The Accounting Department meets each Monday at 10am.'); &#125; generateReports(): void &#123; console.log('Generating accounting reports...'); &#125;&#125;let department: Department; // 允许创建一个对抽象类型的引用department = new Department(); // Error: 不能创建一个抽象类的实例department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值department.printName();department.printMeeting();department.generateReports(); // Error: 方法在声明的抽象类中不存在 Tipsclass Greeter &#123; static standardGreeting = \"Hello, there\"; greeting: string; greet() &#123; if (this.greeting) &#123; return \"Hello, \" + this.greeting; &#125; else &#123; return Greeter.standardGreeting; &#125; &#125;&#125;let greeter1: Greeter;greeter1 = new Greeter();console.log(greeter1.greet());// typeof Greeter，意思是取Greeter类的类型，而不是实例的类型。// greeterMaker 包含了 Greeter 类的所有静态成员和构造函数。 let greeterMaker: typeof Greeter = Greeter;greeterMaker.standardGreeting = \"Hey there!\";let greeter2: Greeter = new greeterMaker();console.log(greeter2.greet());","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://haohaio.github.io/tags/TypeScript/"}]},{"title":"TypeScript 之 Interface","slug":"typescript-interface","date":"2019-07-25T02:34:11.000Z","updated":"2019-08-21T06:55:55.536Z","comments":true,"path":"front-end/typescript-interface-1564022051.html","link":"","permalink":"https://haohaio.github.io/front-end/typescript-interface-1564022051.html","excerpt":"","text":"TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 在 TypeScript 里，接口的作用就是为这些类型命名和以及定义校验规则。 // 使用接口来描述一个拥有 firstName 和 lastName 字段的对象 (firstName 和 lastName 两个字段是必须的)interface Person &#123; firstName: string; lastName: string;&#125;function greeter(person: Person) &#123; return \"Hello, \" + person.firstName + \" \" + person.lastName;&#125;// 只要保证包含了接口要求的结构就可以（还可有其它字段），顺序也没有要求，也不必明确地使用 implements 语句let user = &#123; firstName: \"Jane\", lastName: \"User\" &#125;;document.body.innerHTML = greeter(user); 可选属性接口里的属性不全都是必需的。 当使用了可选属性时，不能引用接口内不存在的属性 interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; let newSquare = &#123; color: \"white\", area: 100 &#125;; if (config.clor) &#123; // Error：属性“clor”在类型“SquareConfig”上不存在 newSquare.color = config.clor; &#125; if (config.color) &#123; newSquare.color = config.color; &#125; if (config.width) &#123; newSquare.area = config.width * config.width; &#125; return newSquare;&#125;let mySquare = createSquare(&#123; color: \"black\" &#125;);// Error：类型“&#123; color: string; type: string; &#125;”的参数不能赋给类型“SquareConfig”的参数let mySquare = createSquare(&#123; color: \"black\" &#125;); 只读属性interface Point &#123; readonly x: number; readonly y: number;&#125;let p1: Point = &#123; x: 10, y: 20 &#125;;p1.x = 5; // Error TypeScript 具有 ReadonlyArray&lt;T&gt; 类型，它与 Array&lt;T&gt; 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改 let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // Error: 类型“readonly number[]”中的索引签名仅允许读取ro.push(5); // Error: 类型“readonly number[]”上不存在属性“push”ro.length = 100; // Error: Cannot assign to 'length' because it is a read-only property.a = ro; // Error: The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 额外的属性检查先来看个栗子： interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; let newSquare = &#123; color: \"white\", area: 100 &#125;; if (config.color) &#123; newSquare.color = config.color; &#125; if (config.width) &#123; newSquare.area = config.width * config.width; &#125; return newSquare;&#125;// Error：类型“&#123; color: string; type: string; &#125;”的参数不能赋给类型“SquareConfig”的参数let mySquare = createSquare(&#123; color: \"black\", type: \"simple\" &#125;); 可以看到，传入 createSquare 的参数内，有 color 和 type 两个属性，type 属性不在 SquareConfig 定义的范围内，此时 TypeScript 会认为这段代码可能存在bug。 这是因为对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。 我们可以通过类型断言来绕开检查： let mySquare = createSquare(&#123; color: \"black\", type: \"simple\" &#125; as SquareConfig); 然而，最佳的方式是能够添加一个字符串索引签名（前提是我们能够确定这个对象可能具有某些做为特殊用途使用的额外属性） ： interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125; 还有一种方式可绕开这些检查： let squareOptions = &#123; colour: \"red\", width: 100 &#125;;let mySquare = createSquare(squareOptions); 看上去有些奇怪，我们只是将这个对象赋值给一个另一个变，但由于变量不会经过额外属性检查，所以编译器不会报错。 但我们可能不应该绕开这些检查，而是去审查一下接口，看是否需要对其进行修改。 函数类型我们还可以使用接口来描述函数类型。 interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string): boolean &#123; let result = source.search(subString); return result &gt; -1;&#125; 对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。参数类型和返回值类型也可以省略，TypeScript的类型系统会自行推断。 let mySearch: SearchFunc;mySearch = function (src, sub) &#123; let result = src.search(sub); return result &gt; -1;&#125; 可索引的类型我们还可以用接口描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。 interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = [\"Bob\", \"Fred\"];let myStr: string = myArray[0]; TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值同类型或其子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。 class Animal &#123; name: string;&#125;class Dog extends Animal &#123; breed: string;&#125;// Error：数字索引类型“Animal”不能赋给字符串索引类型“Dog”。interface NotOkay &#123; [x: number]: Animal; [x: string]: Dog;&#125;// OKinterface NotOkay &#123; [x: number]: Dog; [x: string]: Animal;&#125; 类静态部分与实例部分的区别类是具有两个类型的：静态部分的类型和实例的类型。当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。所以我们不能直接在接口内定义构造器方法，然后让类去实现。 interface ClockConstructor &#123; new(hour: number, minute: number);&#125;// Errorclass Clock implements ClockConstructor &#123; currentTime: Date; constructor(h: number, m: number) &#123; &#125;&#125; 类类型和 Java 里接口的基本作用一样，TypeScript 也能明确的强制一个类去符合某种契约。 interface ClockInterface &#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; 继承接口和类一样，接口也可以相互继承。 interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0; 混合类型直接看个栗子：一个对象可以同时做为函数和对象使用，并带有额外的属性 interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number) &#123; &#125;; counter.interval = 123; counter.reset = function () &#123; &#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 接口继承类当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 接口同样会继承到类的private和protected成员。 class Control &#123; private state: any;&#125;interface SelectableControl extends Control &#123; select(): void;&#125;class Button extends Control implements SelectableControl &#123; select() &#123; &#125;&#125;class TextBox extends Control &#123; select() &#123; &#125;&#125;// 错误：“Image”类型缺少“state”属性。class Image implements SelectableControl &#123; select() &#123; &#125;&#125;","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://haohaio.github.io/tags/TypeScript/"}]},{"title":"TypeScript 之 类型","slug":"typescript-type","date":"2019-07-24T07:09:28.000Z","updated":"2019-08-21T07:05:27.635Z","comments":true,"path":"front-end/typescript-type-1563952168.html","link":"","permalink":"https://haohaio.github.io/front-end/typescript-type-1563952168.html","excerpt":"","text":"基础类型booleanlet isDone: boolean = false; numberlet count: number = 6; stringlet name: string = \"bob\"; 数组有两种方式可以定义数组 // 在元素类型后面接上 []let list: number[] = [1, 2, 3];// 使用数组泛型，Array&lt;元素类型&gt;let list: Array&lt;number&gt; = [1, 2, 3]; Tuple（元组）表示一个已知元素数量和类型的数组，各元素的类型不必相同 // Declare a tuple typelet x: [string, number];x = ['hello', 10]; // OKx = [10, 'hello']; // Error// 当访问一个已知索引的元素，会得到正确的类型：console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr'// 当访问一个越界的元素，会使用联合类型替代：x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toStringx[6] = true; // Error, 布尔不是(string | number)类型 enumenum Color &#123;Red, Green, Blue&#125;// 默认情况下，从0开始为元素编号，也可以手动的指定成员的数值。enum Color &#123;Red = 1, Green, Blue&#125;// 或者全部手动指定成员的数值enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;// 我们可以由枚举值得到它的名字enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2];console.log(colorName); // 显示'Green'因为上面代码里它的值是2 anylet notSure: any = 4;notSure = \"maybe a string instead\";notSure = false;let list: any[] = [1, true, \"free\"]; void表示没有任何类型。 // 当一个函数没有返回值时，其返回值类型是 void。function warnUser(): void &#123; console.log(\"This is my warning message\");&#125;// 声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和nulllet unusable: void = undefined; undefined 和 null默认情况下 null 和 undefined 是所有类型的子类型，即可以将它们赋值为其它的类型。其本身的类型用处不是很大。 let u: undefined = undefined;let n: null = null;// 但当指定了--strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自let count: number = undefined; never表示的是那些永不存在的值的类型。 // 返回 never 的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为 neverfunction fail() &#123; return error(\"Something failed\");&#125;// 返回 never 的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。 declare function create(o: object | null): void;create(&#123; prop: 0 &#125;); // OKcreate(null); // OKcreate(42); // Errorcreate(\"string\"); // Errorcreate(false); // Errorcreate(undefined); // Error 高级类型交叉类型交叉类型是将多个类型合并为一个类型： function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123; let result = &lt;T &amp; U&gt;&#123;&#125;; for (let id in first) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; &#125; for (let id in second) &#123; if (!result.hasOwnProperty(id)) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id]; &#125; &#125; return result;&#125;class Person &#123; constructor(public name: string) &#123; &#125;&#125;interface Loggable &#123; log(): void;&#125;class ConsoleLogger implements Loggable &#123; log() &#123; // ... &#125;&#125;var jim = extend(new Person(\"Jim\"), new ConsoleLogger());var n = jim.name;jim.log(); 联合类型（Union Types）function padLeft(value: string, padding: string | number) &#123; // ...&#125;let indentedString = padLeft(\"Hello world\", true); // Error: 类型“true”的参数不能赋给类型“string | number”的参数 类型断言类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你已经进行了必须的检查。 类型断言有两种形式： let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length;// 在JSX中，只能使用 as 语法断言。let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length;let someValue: number = 123;let strLength: number = (someValue as string).length; // Error: Conversion of type 'number' to type 'string' may be a mistakelet someValue: any = 123;let strLength: number = (someValue as string).length; // OKlet someValue: any = [1, 2, 3];let strLength: number = (someValue as string).length; // OK 类型推论TypeScript 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。 最佳通用类型最终的通用类型取自候选类型，计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。 let x = 3; // x: numberlet x = [0, 1, null]; // x: number[]let x = [0, 1, \"hello\"]; // x: (string | number)[] 当候选类型共享相同的通用类型，但类型推论并不能帮我们推论出这个通用类型，此时我们可以手动指出这个通用类型 // Rhino、Elephant、Snake 均继承自 Animallet zoo = [new Rhino(), new Elephant(), new Snake()]; // (Rhino | Elephant | Snake)[]// 指出通用类型let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()]; 上下文类型TypeScript类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”: // mouseEvent 会被推断为 MouseEvent 类型window.onmousedown = function (mouseEvent) &#123; console.log(mouseEvent.number); // Error: 类型 MouseEvent 上不存在属性 number&#125;; // 当上下文类型表达式包含了明确的类型信息，上下文的类型被忽略window.onmousedown = function (mouseEvent: any) &#123; console.log(mouseEvent.number); // OK&#125;;","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://haohaio.github.io/tags/TypeScript/"}]},{"title":"设计模式之 Factory","slug":"design-patterns-factory","date":"2019-06-26T14:05:50.000Z","updated":"2019-06-29T03:14:34.590Z","comments":true,"path":"front-end/design-patterns-factory-1561557950.html","link":"","permalink":"https://haohaio.github.io/front-end/design-patterns-factory-1561557950.html","excerpt":"","text":"简单工厂模式简单工厂其实并不算是一种设计模式，反而比较像是一种编程习惯。让我们先来看一下它的概念： 定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。 直接来个栗子说明一下，下面是两个汽车类，都实现了 Car 的接口： public interface Car &#123; public void run();&#125;public class AudiCar implements Car &#123; @Override public void run() &#123; System.out.println(\"奥迪\"); &#125;&#125;public class BenzCar implements Car &#123; @Override public void run() &#123; System.out.println(\"奔驰\"); &#125;&#125; 下面是工厂类的具体实现： public class CarFactory &#123; public static Car createCar(String carType) &#123; Car car = null; if (carType.equals(\"Audi\")) &#123; car = new CarAudi(); &#125; else if (carType.equals(\"Benz\")) &#123; car = new CarBenz(); &#125; return car; &#125;&#125; 在这个工厂类中通过传入不同的 carType 可以 new 出不同的 Car，结果返回 Car 类型。我们可以这样进行使用： // 创建一辆奥迪类汽车Car audi = CarFactory.createCar(\"Audi\");audi.run();// 创建一辆奔驰类汽车Car benz = CarFactory.createCar(\"Benz\");benz.run(); 简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。 这就是简单工厂模式了，是不是 so easy ~~ 但是当我们需要扩展的时候，例如我们需要创建宝马类的汽车时，不仅需要新增一个 BMWCar 类，还需要对 CarFactory 内部的 createCar 方法，很明显这是违背了开放-封闭原则的。这就引出了工厂方法模式~~ 工厂方法模式 (Factory Method) 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 还是直接来个栗子： public interface CarFactory &#123; public Car createCar();&#125;public class AudiCarFactory implements CarFactory &#123; @Override public Car createCar() &#123; return new AudiCar(); &#125;&#125;public class BenzCarFactory implements CarFactory &#123; @Override public Car createCar() &#123; return new BenzCar(); &#125;&#125; CarFactory carFactory;carFactory = new AudiCarFactory();Car audi = carFactory.createCar();audi.run();carFactory = new BenzCarFactory(); // 只需要替换工厂类，就可以创建其它种类的汽车了Car benz = carFactory.createCar();benz.run(); 此时当我们需要创建宝马类的汽车时，我们只需要新增一个 BMWCar 类和一个 BMWCarFactory 类就行了，不会再对原有的代码进行修改了。 简单工厂模式和工厂方法模式都是集中封装的对象的，使得创建时要更换对象时，不需要做大的改动就可实现，降低了客户端与具体产品的耦合。工厂方法模式是简单工厂模式的进一步抽象和推广。工厂方法模式保持了简单工厂模式的优点，而且克服了简单工厂模式违背开放-封闭原则的缺点。但缺点是由于每增加一个产品，就需要加一个产品工厂的类，增加了额外的开发量。 抽象工厂模式 (Abstract Factory) 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 当我们的汽车工厂不仅仅生产汽车，还需要生产各种汽车配件时。按照工厂方法模式来设计的话，当我们要生产各个品牌的发动机时，就新增一个 EngineFactory 以及相关类，当我们需要生成各个品牌的轮胎时，就新增一个 TyreFactory 以及相关类… 很明显这又违背了我们的依赖倒置原则。依赖倒置原则是说抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对抽象（接口）编程，而不是针对实现细节编程。 从用户的角度来看就是, 通过尽量少的接口变化, 来尽量多地满足需求变化。因为用户只关心调用创建对象的接口, 而不关心对象是如何创建出来的。这时候就引出来抽象工厂模式了，还是举个栗子说明一下： // 新增 Engine 接口、AudiEngine 类、BenzEngine 类以及 Tyre 接口、AudiTyre 类、BenzTyre 类 public interface CarFactory &#123; public Car createCar(); // 创建发动机接口 public Engine createEngine(); // 创建轮胎接口 public Tyre createTyre();&#125; // AudiCarFactory 类、BenzCarFactory 类实现 createEngine 和 createTyre 接口 CarFactory carFactory;carFactory = new AudiCarFactory();Car audi = carFactory.createCar();Engine audiEngine = carFactory.createEngine();Tyre audiTyre = carFactory.createTyre();carFactory = new BenzCarFactory();Car audi = carFactory.createCar();Engine benzEngine = carFactory.createEngine();Tyre benzTyre = carFactory.createTyre(); 可以看到，抽象工厂模式是就是对工厂方法模式的进一步优化。简单来讲，工厂方法只提供了一个方法用来创建一个产品，而抽象工厂提供了一组接口可用来创建一组相关的产品。 但是不知道大家注意了没有，当我们需要扩展的时候，比如我们要生产一种其它的汽车配件时，就会发现我们需要对原有的代码进行修改，这又违背了开放-封闭原则。。。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"https://haohaio.github.io/tags/DesignPatterns/"}]},{"title":"设计模式之 Singleton","slug":"design-patterns-singleton","date":"2019-06-24T09:29:34.000Z","updated":"2019-07-05T01:09:48.850Z","comments":true,"path":"front-end/design-patterns-singleton-1561368574.html","link":"","permalink":"https://haohaio.github.io/front-end/design-patterns-singleton-1561368574.html","excerpt":"","text":"Singleton 可以说是设计模式中最简单的一个模式了，但是我们要想用好它的话，也不简单~~ 我们先来看一下单例模式的概念： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 Java 中的单例下面我们先来看在 Java 中如何实现单例模式： 懒汉式（需要的时候才会去实例化），教科书版本class Singleton &#123; private static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 但是很明显，这样实现单例会有线程安全的问题，当有多个线程并行调用 getInstance() 方法的时候，就会创建多个 instance 实例。 懒汉式，同步方法为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。 class Singleton &#123; private static Singleton instance = null; private Singleton() &#123; &#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法，该线程调用结束后才能被其他的线程调用。 懒汉式，同步代码块上面的同步方法 synchronized 的范围是整个方法, 而同步代码块方法将 synchronized 的范围缩小为 Block class Singleton &#123; private static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 看起来我们进行了改进，现在多个线程可同时调用 getInstance() 方法，但是又造成了线程不安全的问题。当同步代码块结束后立即被其它线程抢占了，也可以执行同步代码块内的代码，这就会和教科书版本一样创建了多个 instance 实例。 懒汉式，双重检验锁双重检验锁模式（double checked locking pattern），之所以称其为双重检查锁，是因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。 class Singleton &#123; private volatile static Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 现在看起来已经线程安全了，但是还是有问题的。因为 instance = new Singleton() 这句，这并非是一个原子操作。事实上在 JVM 中这句话大概做了下面 3 件事情： 给 instance 分配内存 调用 Singleton 的构造函数来初始化成员变量 将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了） 但是在 JVM 的即时编译器中存在指令重排序(Re-Order)的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。 如果是后者，则在 3 执行完毕、2 未执行之前，被其它线程抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以其它线程会直接返回 instance，但是得到的instance是还没有完全构造的对象，然后就会顺理成章地报错。 懒汉式，双重检验锁 + volatile在 JDK5 以后，我们可以使用 volatile 关键字来解决这个问题，将变量声明成 volatile 以禁止 JVM 指令重排序(Re-Order)优化。 public class Singleton &#123; // 声明成 volatile private volatile static Singleton instance; private Singleton ()&#123; &#125; public static Singleton getSingleton() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 这样终于是和同步方法版本一样可靠了~~ 饿汉式 (当 class 文件被加载的时候，初始化单例)class Singleton &#123; private static final Singleton instance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 看起来非常简单，并且天生是线程安全的。如果不考虑 Lazy Loading 带来的这些微小的内存消耗和优化的话，看起来这是一个很不错的选择。 iOS 中的单例再让我们看一下 iOS 中是怎么实现单例模式的： 这里就不考虑 使用 new、alloc] init]、copy 等方法可以创造出不同对象的问题了。 + (instancetype)getInstance &#123; static Singleton *instance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance = [[self alloc] init]; &#125;); return instance;&#125; 可以看到，与 Java 中的懒汉式版本是基本一样的，线程安全是使用 GCD 里的 dispatch_once (保证在多个线程同时调用的时候，dispatch_once 只会执行一次) 来保证的。 JavaScript 中的单例模拟传统面向对象语言实现的单例var Singleton = function(name) &#123; this.name = name; this.instance = null;&#125;Singleton.prototype.getName = function() &#123; return this.name;&#125;Singleton.getInstance = function(name) &#123; if(!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125; 全局变量全局变量不是单例模式，但是一个全局变量确实是独一无二的。 然而全局变量存在很多问题，它很容易造成命名空间污染。我们有必要尽量的减少全局变量的使用，即使需要，也要把它的污染将至最低。 使用命名空间var MyApp = &#123; event: &#123;&#125;, dom: &#123; style: &#123;&#125; &#125;,&#125; 适当的使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量。 使用闭包封装私有变量将变量封装在闭包的内部，只暴露一些接口与外界通讯。 var user = (function()&#123; var _name = 'xiaoming'; var _age = 26; return &#123; getUserName: function() &#123; return _name; &#125;, getUserAge: function() &#123; return _age; &#125; &#125;&#125;)() 实际情况中的单例举个栗子，我们在写弹窗的时候，一般都要写一个遮罩层，很明显我们可以把这个遮罩层设计成在页面里是唯一的。我们可以设计成这个样子： var createMask = (function() &#123; var mask; return function() &#123; if(!mask) &#123; mask = document.createElement('div'); mask.style.display = 'none'; document.body.appendChild(mask); &#125; return mask; &#125;&#125;)() 但是上面代码还是有一些问题的，很明显它是违背了单一职责原则的，创建对象和管理单例的逻辑都放在 createMask 对象内部了。下面我们优化一下： var getSingleton = function(fn) &#123; var result; return function() &#123; return result || (result = fn.apply(this, arguments)); &#125;&#125;var createMask = function()&#123; var mask = document.createElement('div'); mask.style.display = 'none'; document.body.appendChild(mask); return mask;&#125;var createSingleMask = getSingleton(createMask); 这样看起来还不错，getSingleton 方法还可以用来通用的创建其它单例哟~~ 小结单例模式看起来非常简单，但是用起来的时候还是有很多要注意的地方。因为 JavaScript 与传统面向对象语言之间的差异性，还会有其它更适合在方法在 JavaScript 中创建单例。 参考设计模式 之 Singleton(Java实现)Java 单例真的写对了么?JS 单例模式","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"https://haohaio.github.io/tags/DesignPatterns/"}]},{"title":"Java内存模型简介","slug":"java-memory-model","date":"2019-06-24T07:36:52.000Z","updated":"2019-06-25T14:37:07.281Z","comments":true,"path":"back-end/java-memory-model-1561361812.html","link":"","permalink":"https://haohaio.github.io/back-end/java-memory-model-1561361812.html","excerpt":"","text":"简介 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。 Java 内存模型的抽象示意图如下： 从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤： 线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。 然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。 从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。 重排序在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。但是这也会带来一些线程安全问题。 在进行重排序后，处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致。例如： 初始状态：a = b = 0Processor A: Processor B:a = 1; // A1 b = 2; // B1x = b; // A2 y = a; // B2处理器允许执行后得到结果：x = y = 0 具体原因如下图所示： 由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对读/写操作重排序。 如上所示，当多个线程同时访问一个数据的时候，可能本地内存的修改没有及时刷新到主内存，所以就会发生线程安全问题。 happens-before从 JDK5 开始，java 使用新的 JSR -133 内存模型。JSR-133 提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。与程序员密切相关的 happens-before 规则如下： 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。 volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。 基于 volatile 变量规则，可以在 Java 中可以使用 volatile 关键字来修饰多线程间共享变量，使该变量在多线程之间可见。 参考深入理解 Java 内存模型（一）——基础","categories":[{"name":"后端","slug":"back-end","permalink":"https://haohaio.github.io/categories/back-end/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://haohaio.github.io/tags/Java/"}]},{"title":"Flutter 布局组件简介","slug":"flutter-layout-widgets","date":"2019-05-28T02:43:11.000Z","updated":"2019-06-04T05:59:57.421Z","comments":true,"path":"front-end/flutter-layout-widgets-1559011391.html","link":"","permalink":"https://haohaio.github.io/front-end/flutter-layout-widgets-1559011391.html","excerpt":"","text":"Flutter 是使用 Layout Widgets 来进行布局的，今天我们就来了解一下相关的布局组件。 Single-child layout widgetsContainer A convenience widget that combines common painting, positioning, and sizing widgets. 属性 key：container 唯一标识符，用于查找更新。 alignment：控制 child 的对齐方式，如果 container 或者 container 父节点尺寸大于 child 的尺寸，这个属性设置会起作用，有很多种对齐方式。 padding：内边距。 color：用来设置 container 背景色。 decoration：绘制在child后面的装饰，设置了decoration的话，就不能设置color属性，否则会报错，此时应该在 decoration 中进行颜色的设置。 foregroundDecoration：绘制在child前面的装饰。 width：container 的宽度，设置为 double.infinity 可以强制在宽度上撑满。不设置，则根据 child 和父节点两者一起布局。 height：container 的高度，设置为 double.infinity 可以强制在高度上撑满。 constraints：添加到 child 上额外的约束条件。 margin：外边距。 transform：设置 container 的变换矩阵，类型为 Matrix4。 child：container 中的内容 widget。 我们可以用 Container 来设置间隔、背景、边框、圆角、对齐等。 Padding A widget that insets its child by the given padding. 我们可以用 Padding 来设置间隔。（Container 中 的 margin 以及 padding 属性都是利用 Padding 控件去实现的。） Align属性 key alignment：对齐方式 widthFactor：child 的宽度倍数 heightFactor：child 的高度倍数 child A widget that aligns its child within itself and optionally sizes itself based on the child’s size. 我们可以用 Align 来设置对齐。若不设 widthFactor 和 heightFactor, Align 会尽量的扩展自己的尺寸。 Center A widget that centers its child within itself. Center 继承自 Align，只不过是将 alignment 设置为 Alignment.center，其他属性例如 widthFactor、heightFactor，布局行为，都与 Align 完全一样。 FittedBox Scales and positions its child within itself according to fit. 我们可以用FittedBox来处理缩放。FittedBox 如果外部有约束的话，按照外部约束调整自身尺寸。如果没有外部约束条件，则跟 child 尺寸一致，指定的缩放以及位置属性将不起作用。 AspectRatio A widget that attempts to size the child to a specific aspect ratio. AspectRatio 的作用是调整 child 到设置的宽高比。AspectRatio首先会在布局限制条件允许的范围内尽可能的扩展，widget的高度是由宽度和比率决定的，类似于BoxFit中的contain，按照固定比率去尽量占满区域。如果在满足所有限制条件过后无法找到一个可行的尺寸，AspectRatio最终将会去优先适应布局限制条件，而忽略所设置的比率。 ConstrainedBox A widget that imposes additional constraints on its child. ConstrainedBox 的 作用就是给 child 添加约束（constraints）。 Baseline A widget that positions its child according to the child’s baseline. 我们可以用 Baseline 来处理字符对齐。 FractionallySizedBox A widget that sizes its child to a fraction of the total available space. For more details about the layout algorithm, see RenderFractionallySizedOverflowBox. child 可以通过 FractionallySizedBox 在其可用区域里取百分比尺寸。 IntrinsicHeight A widget that sizes its child to the child’s intrinsic height. IntrinsicHeight 的作用是调整 child 到固定的高度。 IntrinsicWidth A widget that sizes its child to the child’s intrinsic width. IntrinsicWidth 的作用是调整 child 到固定的宽度。 LimitedBox A box that limits its size only when it’s unconstrained. LimitedBox 的作用是对 child 的最大宽高进行限制。 Offstage A widget that lays the child out as if it was in the tree, but without painting anything, without making the child available for hit testing, and without taking any room in the parent. Offstage 的作用是通过一个参数，来控制 child 是否显示。 OverflowBox A widget that imposes different constraints on its child than it gets from its parent, possibly allowing the child to overflow the parent. OverflowBox 的作用是允许 child 超出 parent 的范围显示。 SizedBox A box with a specified size. SizedBox 的作用就是设置具体的宽高。 SizedOverflowBox A widget that is a specific size but passes its original constraints through to its child, which will probably overflow. SizedOverflowBox 是 SizedBox 与 OverflowBox 的结合体。 Transform A widget that applies a transformation before painting its child. Transform 就是对 child 做矩阵变换的，即平移、旋转、缩放等操作。 CustomSingleChildLayout A widget that defers the layout of its single child to a delegate. CustomSingleChildLayout提供了一个控制child布局的delegate，我们可以通过这个控件去封装一些基础的控件（尺寸），供他人使用。 Multi-child layout widgetsRow &amp; Column A widget that displays its children in a horizontal array. 类似于 CSS3 中的 Flex 布局。可结合 Expanded 使用，设置 children 中各 widget 的 flex 值。 Stack A widget that positions its children relative to the edges of its box. 我们可以用 Stack 来做需要叠加显示的布局。 IndexedStack A Stack that shows a single child from a list of children. IndexedStack 继承自 Stack，它的作用是显示第 index 个 child，其他 child 都是不可见的。所以 IndexedStack 的尺寸永远是跟最大的子节点尺寸一致。 GridView A scrollable, 2D array of widgets. GridView 就是一个滚动的多列列表。 Flow A widget that implements the flow layout algorithm. Flow 可以用来在定制化流式布局，但是写起来比较复杂，但胜在灵活性以及其高效。 Table A widget that uses the table layout algorithm for its children. Table 可以用来做表格展示。 Wrap A widget that displays its children in multiple horizontal or vertical runs. Wrap 可以用来处理自动换行的布局。Flow 可以很轻易的实现 Wrap 的效果，从效率上讲，Flow 肯定会比 Wrap 高，但是 Wrap 使用起来会方便一些。 ListBody A widget that arranges its children sequentially along a given axis. ListBody 的作用是按给定的轴方向，按照顺序排列子节点。不常直接使用，一般都会配合 ListView 或者 Column 等控件使用 CustomMultiChildLayout A widget that uses a delegate to size and position multiple children. CustomMultiChildLayout 的作用是通过 delegate 实现 多节点的自定义布局（尺寸、位置）。 LayoutBuilder Builds a widget tree that can depend on the parent widget’s size. ListView A scrollable, linear list of widgets. ListView 可以用来做列表展示。 Expanded A widget that expands a child of a Row, Column, or Flex. 配合 Row &amp; Column 使用，设置 child 的 flex 值。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://haohaio.github.io/tags/Flutter/"}]},{"title":"Flutter 入门","slug":"flutter-quick-start","date":"2019-04-03T01:28:47.000Z","updated":"2019-04-08T06:36:52.240Z","comments":true,"path":"front-end/flutter-quick-start-1554254927.html","link":"","permalink":"https://haohaio.github.io/front-end/flutter-quick-start-1554254927.html","excerpt":"","text":"简介Flutter allows you to build beautiful native apps on iOS and Android from a single codebase. Flutter 是 Google 推出并开源的移动应用开发框架，采用 Dart 语言进行开发，使用自绘引擎渲染视图，主打跨平台、高保真、高性能。 开发环境安装 Flutter 使用镜像 # Flutter官方为中国开发者搭建的临时镜像export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 以 Mac 环境为例进行安装，其它环境请看 Windows、Linux 下载 SDK，然后解压到相应目录中，并添加 flutter 相关工具到 path 中： # 将 SDK 解压到了 ~/Flutter/sdk/ 目录下$ export PATH=~/Flutter/sdk/flutter/bin:$PATH 运行 flutter doctor # 通过 flutter 提供的命令检查当前环境并在终端窗口中显示报告$ flutter doctor 根据提示直接复制命令继续执行即可 安装 Xcode 和 Android StudioXcode 和 Android Studio 是进行原生开发的 IDE，安装后也会便于进行 Flutter 开发。具体安装自行了解一下，可看 参考链接 IDE Visual Studio Code (VS Code)安装 Flutter 插件即可 Android Studio安装 Flutter 和 Dart 插件即可 工程新建项目（VS Code） 打开命令面板（Command + shift + P），输入 “flutter”, 然后选择 “Flutter: New Project” action 输入 Project 名称 (如myapp), 然后按回车键确认 指定放置项目的位置，然后按蓝色的确定按钮 等待项目创建继续，并显示main.dart文件 运行项目（VS Code） 在 VS Code 的右下角选择目标设备 按 F5 键进行调试 打包Android 创建 keystore (若已有keystore，跳至下一步) # 通过 Java JDK 的 keytool 在根目录下创建一个 key.jks 文件$ keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key 引用keystore 创建一个名为 &lt;app dir&gt;/android/key.properties 的文件，其中包含对密钥库的引用： storePassword=&lt;password from previous step&gt;keyPassword=&lt;password from previous step&gt;keyAlias=keystoreFile=&lt;location of the key store file, e.g. /Users/&lt;user name&gt;/key.jks&gt; 在 gradle 中配置签名 替换: android &#123; 为： def keystorePropertiesFile = rootProject.file(\"key.properties\")def keystoreProperties = new Properties()keystoreProperties.load(new FileInputStream(keystorePropertiesFile))android &#123; 替换: buildTypes &#123; release &#123; // TODO: Add your own signing config for the release build. // Signing with the debug keys for now, so `flutter run --release` works. signingConfig signingConfigs.debug &#125;&#125; 为： signingConfigs &#123; release &#123; keyAlias keystoreProperties['keyAlias'] keyPassword keystoreProperties['keyPassword'] storeFile file(keystoreProperties['storeFile']) storePassword keystoreProperties['storePassword'] &#125;&#125;buildTypes &#123; release &#123; signingConfig signingConfigs.release &#125;&#125; 执行命令打包 # 在 &lt;app dir&gt; 下执行命令（非 android/ 目录下）$ flutter build apk (flutter build 默认会包含 --release选项) 打包好的APK位于 &lt;app dir&gt;/build/app/outputs/apk/ iOS和正常的iOS项目一样打包，具体可查看 详细介绍 热补丁目前 Flutter 是默认不支持热补丁的，暂时也未发现靠谱的热补丁方法。 架构DartDart 是由 Google 开发并开源的应用编程语言。我们需要用其进行 Flutter 开发。 简单介绍一些语法： 变量声明 var t;t=\"hi world\";t=1000; // errordynamic t;Object x;t = \"hi world\";x = 'Hello Object';t = 1000; // okx = 1000; // ok// dynamic 声明的对象编译器会提供所有可能的组合, 而 Object 声明的对象只能使用 Object 的属性与方法dynamic a;Object b;main() &#123; a = \"\"; b = \"\"; printLengths();&#125;printLengths() &#123; print(a.length); // ok print(b.length); // error: The getter 'length' is not defined for the class 'Object'&#125; 异步处理 Future.delayed(new Duration(seconds: 2),()&#123; //return \"hello world!\"; throw AssertionError(\"Error\");&#125;).then((data)&#123; //执行成功会走到这里 print(data);&#125;).catchError((e)&#123; //执行失败会走到这里 print(e);&#125;).whenComplete(()&#123; //无论成功或失败都会走到这里&#125;);// 多个异步任务Future.wait([ // 2秒后返回结果 Future.delayed(new Duration(seconds: 2), () &#123; return \"hello\"; &#125;), // 4秒后返回结果 Future.delayed(new Duration(seconds: 4), () &#123; return \" world\"; &#125;)]).then((results)&#123; print(results[0]+results[1]);&#125;).catchError((e)&#123; print(e);&#125;);// 使用 Future 消除 callback helllogin(\"alice\",\"******\").then((id)&#123; return getUserInfo(id);&#125;).then((userInfo)&#123; return saveUserInfo(userInfo);&#125;).then((e)&#123; // 执行接下来的操作&#125;).catchError((e)&#123; // 错误处理 print(e);&#125;); 布局Flutter 有一套自己的布局机制。其核心就是 Widget。在Flutter中，几乎所有的对象都是一个 Widget。 简单介绍一下： new Text('Hello World', style: new TextStyle(fontSize: 32.0));new Icon(Icons.star, color: Colors.red[500]);new Center( child: new Text('Hello World', style: new TextStyle(fontSize: 32.0)); Widget与原生开发中“控件”不同的是，Flutter 中的 Widget 的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 GestureDetector Widget、用于应用主题数据传递的 Theme 等等。 其实在 Flutter 中，Widget 的功能是“描述一个UI元素的配置数据”，Flutter 中真正代表屏幕上显示元素的类是 Element，也就是说 Widget 只是描述 Element 的一个配置。不过，由于 Element 是通过 Widget 生成，所以它们之间有对应关系，所以在大多数场景，我们可以宽泛地认为 Widget 树就是指UI控件树或UI渲染树。 @immutable// DiagnosticableTree 即“诊断树”，主要作用是提供调试信息。abstract class Widget extends DiagnosticableTree &#123; const Widget(&#123; this.key &#125;); // key属性类似于 React/Vue 中的 key，主要的作用是决定是否在下一次 build 时复用旧的widget，决定的条件在 canUpdate()方法中。 final Key key; @protected // 由 Flutter Framework 隐式调用，来生成对应的 Element 对象，构建 UI 树。 Element createElement(); @override String toStringShort() &#123; return key == null ? '$runtimeType' : '$runtimeType-$key'; &#125; @override void debugFillProperties(DiagnosticPropertiesBuilder properties) &#123; super.debugFillProperties(properties); properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense; &#125; // 判断是否用新的 Widget 对象去更新旧UI树上所对应的 Element 对象的配置。 static bool canUpdate(Widget oldWidget, Widget newWidget) &#123; return oldWidget.runtimeType == newWidget.runtimeType &amp;&amp; oldWidget.key == newWidget.key; &#125;&#125; 在Flutter开发中，我们一般都不用直接继承 Widget 类来实现 Widget，相反，我们通常会通过继承 StatelessWidget 和 StatefulWidget 来间接继承 Widget类来实现，而 StatelessWidget 和 StatefulWidget 都是直接继承自 Widget 类。 资源Flutter 官网Flutter 中文网Awesome FlutterFlutter 掘金社区 小结 技术类型 UI渲染方式 性能 开发效率 动态化 框架代表 H5 + 原生 WebView渲染 一般 高 支持 Cordova、Ionic JavaScript + 原生渲染 原生控件渲染 好 高 支持 RN、Weex 自绘UI + 原生渲染 调用系统API渲染 好 Flutter高，QT低 默认不支持 QT、Flutter","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://haohaio.github.io/tags/Flutter/"}]},{"title":"使用 Hexo 搭建属于你自己的博客","slug":"hexo-blog","date":"2019-03-08T01:40:16.000Z","updated":"2019-03-11T05:46:49.561Z","comments":true,"path":"others/hexo-blog-1552009216.html","link":"","permalink":"https://haohaio.github.io/others/hexo-blog-1552009216.html","excerpt":"","text":"为什么要搭建个人博客博客，我个人觉得更多是写给自己看的，主要是把自己学到的东西给记录下来，进行总结，从而让自己有一定的提升。其次也能将自己学来的知识与他人进行分享，帮助他人解决问题，在分享的过程中他人和自己都能获得一定的提升。 至于为什么要个人建站，是因为本人是做 Web 开发的，所以想要定制一个自己喜欢的个人博客（其实就是从网上众多的主题中挑选一个自己顺眼的，自己再小小修改一下），想怎么来就怎么来~~ 今天就来介绍一下如何使用 Hexo 来搭建自己的个人博客。 HexoHexo 是一个基于 Node.js, 支持 Markdown 的快速、简洁且高效的博客框架。 安装 Hexo需先安装 Node.js 和 Git npm install -g hexo-cli 创建博客执行命令 # 生成博客目录并安装依赖$ hexo init blog &amp;&amp; cd blog &amp;&amp; npm install 生成的主要文件目录如下： ├── /scaffolds/ # 模版文件夹：新建文章时的模板├── /sources/ # 资源文件夹│ ├── /_posts/ # 文章文件夹├── /themes/ # 主题文件夹：Hexo 根据主题来生成静态页面├── _config.yml # 网站配置信息├── package.json # 应用程序信息 建议将自己的博客用 Git 管理起来哦~~ 启动服务执行命令 # 会在本地启动一个 http server，用来访问我们的个人博客$ hexo server (hexo s) 启动服务后即可在 本地 访问自己刚刚搭建的博客。 写作执行命令 # hexo new [layout] &lt;title&gt; 创建一篇新文章，layout 默认为 post（scaffolds/post）$ hexo n 我的第一篇博客 推荐一份 Markdown 语法指南 部署我们可以将我们的个人博客部署在服务器上，并代理到我们自己的域名，但这些都是需要 ￥￥ 的。所以推荐一些免费的服务来用来部署我们的博客，比如 GitHub、Coding 和 码云 等，这些平台提供了免费的 Pages 服务，可以用来部署我们的博客。下面以 Github Pages 为例，讲一下如何进行部署，其它平台的操作也是大同小异。 GitHub Pages GitHub 提供了 GitHub Pages 的服务，免费提供 username.github.io 的域名，来让我们部署一个静态网页。 首先我们要创建一个 GitHub 帐号，用户名一定要想好了再创建，因为用户名会关系到我们个人博客的域名哦~~ 然后创建一个名称为 username.github.io 的项目，然后点击项目的配置，就会发现，我们的Pages服务已经OK了,如下图所示 接下来只需要部署我们的代码就可以了 配置 _config.yml deploy:- type: git repo: https://github.com/haohaio/haohaio.github.io.git branch: master 执行命令 # 安装依赖以通过 Git 进行部署，然后生成静态文件进行部署$ npm install hexo-deployer-git --save &amp;&amp; hexo g &amp;&amp; hexo d 最好配置一下 GitHub 的 SSH key，将 repo 改成 SSH 类型的，这样部署的时候就不需要输入用户名和密码啦~~ 然后访问一下 username.github.io 就能看到自己搭建的博客啦~~ 主题但现在我们搭建的博客看上去还不是那么的好看，功能也很少，我们可以通过更换主题来改变一下我们博客的面貌。Hexo 提供了一份主题列表, 或者可以去 GitHub 上搜索 hexo theme 来选择一个喜欢的主题进行更换。 那我们就以 GitHub 上 Star 最多的 hexo-theme-next 为例来更换我们的主题。 执行命令 # 创建主题文件夹$ mkdir themes/next# 获取主题资源文件$ git clone https://github.com/iissnan/hexo-theme-next themes/next 配置 _config.yml theme: next 执行命令 # 重新部署$ hexo g &amp;&amp; hexo d 刷新页面后就可以看到我们已经成功的更换主题了，具体还可以根据 详细介绍 来让我们的博客更加美观、强大。 结语坚持！坚持！坚持！一定要把写博客的习惯坚持下去~~","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://haohaio.github.io/tags/hexo/"}]},{"title":"Spring Boot 日志配置","slug":"spring-boot-logging","date":"2019-01-25T03:02:39.000Z","updated":"2019-01-25T08:06:38.260Z","comments":true,"path":"back-end/spring-boot-logging-1548385359.html","link":"","permalink":"https://haohaio.github.io/back-end/spring-boot-logging-1548385359.html","excerpt":"","text":"Spring Boot 给我们集成了默认的日志系统，但有时我们需要自定义一些配置，今天我们就来了解一下如何进行自定义配置。 Spring Boot 默认采用了 slf4j+logback 的组合形式。 通过 application.properties 修改默认配置我们可以在 application.properties 文件中设置来修改日志默认配置： # 日志级别分为 TRACR &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR 五个级别，优先级由低到高# 修改日志的 root 级别（默认日志级别）logging.level.root=debug# 调整指定包的日志级别logging.level.com.haohaio=trace# 当 logging.file 和 logging.path 同时设置时，logging.path 不生效# 输入到当前项目根路径下的 spring-boot.log 文件中logging.file=spring-boot.log# 输入到当前项目根路径下的 logs 文件夹下的 spring-boot.log 文件中logging.file=logs/spring-boot.log# 输入到当前项目根路径下的 logs 文件夹里 spring.log 文件中logging.path=logs# 修改控制台日志格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; === %msg%n# 修改输入到日志文件中日志格式logging.pattern.file=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-5level &gt;&gt;&gt; %logger&#123;50&#125; &gt;&gt;&gt; %msg%n 日志输出格式说明： %d 表示输出时间，%thread 表示输出当前线程名，%-5level 表示输出日志级别，左对齐5个字符宽度，%logger{50} 表示输出全类名最长50个字符，超过按照句点分割，%msg 表示日志信息，%n 表示换行符 自定义配置我们可以 resources 目录下创建对应日志框架的自定义配置文件，来进行自定义配置。 日志系统 自定义日志配置文件名 Logback logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties 自定义 Logback 日志配置接下来我们可以对默认的 Logback 进行自定义配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- scan：当此属性设置为 true 时，配置文件如果发生改变，将会被重新加载，默认值为true。 scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当 scan 为 true 时，此属性生效。默认的时间间隔为 1 分钟。 debug：当此属性设置为 true 时，将打印出 logback 内部日志信息，实时查看 logback 运行状态。默认值为 false。--&gt;&lt;configuration scan=\"false\" scanPeriod=\"60 seconds\" debug=\"false\"&gt; &lt;!-- 定义日志的根目录 --&gt; &lt;property name=\"LOG_HOME\" value=\"logs\" /&gt; &lt;!-- 定义日志文件名称 --&gt; &lt;property name=\"appName\" value=\"spring-boot\"&gt;&lt;/property&gt; &lt;!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 --&gt; &lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-5level &gt;&gt;&gt; %logger&#123;50&#125; &gt;&gt;&gt; %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt; &lt;appender name=\"appLogAppender\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 指定日志文件的名称 --&gt; &lt;file&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;.log&lt;/file&gt; &lt;!-- TimeBasedRollingPolicy：最常用的滚动策略，它根据时间来制定滚动策略。--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 滚动时产生的文件的存放位置及文件名称 %d&#123;yyyy-MM-dd&#125;：按天进行日志滚动, %i：当文件大小超过 maxFileSize 时，按照 i 进行文件滚动 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;!-- 只保存最近 30 天的文件 --&gt; &lt;MaxHistory&gt;30&lt;/MaxHistory&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;!-- 日志输出格式 --&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [ %thread ] - [ %-5level ] [ %logger&#123;50&#125; : %line ] - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- logger 主要用于存放日志对象，也可以定义日志类型、级别，name：表示匹配的 logger 类型前缀，也就是包的前半部分，additivity：false：表示rootLogger 的 appender-ref 无效，true：表示当前 logger 的 appender-ref 和 rootLogger 的 appender-ref 都有效 --&gt; &lt;logger name=\"com.haohaio\" level=\"trace\" /&gt; &lt;logger name=\"org.springframework\" level=\"debug\" additivity=\"false\"&gt;&lt;/logger&gt; &lt;!-- root 与 logger 是父子关系，没有特别定义则默认为 root。--&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"stdout\" /&gt; &lt;appender-ref ref=\"appLogAppender\" /&gt; &lt;/root&gt;&lt;/configuration&gt; 使用 Profile 特殊配置我们还可以使用 Profile 特殊配置，根据不同的环境来使用不同的配置。但我们首先需要将自定义日志配置文件名 logback.xml 改为 logback-spring.xml。比如： &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; === [%thread] === %-5level === %logger&#123;50&#125; === %msg%n&lt;/pattern&gt;&lt;/springProfile&gt;&lt;springProfile name=\"prod\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-5level &gt;&gt;&gt; %logger&#123;50&#125; &gt;&gt;&gt; %msg%n&lt;/pattern&gt;&lt;/springProfile&gt; 切换日志框架我们可以在项目的 pom.xml 文件里切换日志框架。比如切换为 log4j2 日志框架： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!-- 先排除 spring-boot-starter-logging --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- 再使用 log4j2 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 切换完成后我们还可以使用 log4j2 对应的 log4j2.xml 和 log4j2-spring.xml 来进行自定义配置。 文档Spring Boot Logging","categories":[{"name":"后端","slug":"back-end","permalink":"https://haohaio.github.io/categories/back-end/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://haohaio.github.io/tags/spring/"}]},{"title":"Canvas学习笔记七：动画","slug":"canvas-animation","date":"2019-01-14T03:07:15.000Z","updated":"2019-01-15T01:41:40.988Z","comments":true,"path":"front-end/canvas-animation-1547435235.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-animation-1547435235.html","excerpt":"","text":"使用 requestAnimationFrame() 方法让做动画 不要用 setInterval() 或 setTimeout() 来做动画setInterval() 与 setTimeout() 并不能提供和制作动画所需的精准计时机制。它们只是让应用程序能在某个大致时间点上运行代码的通用方法而已。 不应主动命令浏览器何时去绘制下一帧动画，这应有浏览器通知你在调用 setInterval() 与 setTimeout() 时，开发者会主动告知浏览器绘制下一帧动画的时间。然而，调用者并不知道绘制下一帧动画的最佳时机，浏览器肯定比开发者更了解这个时机。所以应该让浏览器在它觉得可以绘制下一帧动画时通知我们。 function animate(time) &#123; // Update and draw animation objects requsetAnimationFrame(animate); // sustain the animation&#125;requestAnimationFrame(animate); // start the animation requestAnimationFrame() 不需要调用者指定帧速率，浏览器会自行决定最佳的帧速率 我们还可以调用 cancelRequestAnimationFrame(long handle) 方法来将原来 requestAnimationFrame() 方法所注册的函数回调给取消执行。requestAnimationFrame() 方法会返回一个 long 型的对象，用作标识回调函数的句柄 (handle)，可传入 cancelRequestAnimationFrame() 方法来取消回调函数的执行。 但是 requestAnimationFrame() 的兼容性并不是很好，只兼容到了 IE10 以及以后的版本。我们可以定义一个 “Polyill式方法” 来向下兼容，具体代码如下： window.requestNextAnimationFrame = (function() &#123; var originalWebkitRequestAnimationFrame = undefined, wrapper = undefined, callback = undefined, geckoVersion = 0, userAgent = navigator.userAgent, index = 0, self = this; // Workaround for Chrome 10 bug where Chrome // does not pass the time to the animation function if (window.webkitRequestAnimationFrame) &#123; // Define the wrapper wrapper = function(time) &#123; if (time === undefined) &#123; time = +new Date(); &#125; self.callback(time); &#125;; // Make the switch originalWebkitRequestAnimationFrame = window.webkitRequestAnimationFrame; window.webkitRequestAnimationFrame = function(callback, element) &#123; self.callback = callback; // Browser calls the wrapper and wrapper calls the callback originalWebkitRequestAnimationFrame(wrapper, element); &#125; &#125; // Workaround for Gecko 2.0, which has a bug in // mozRequestAnimationFrame() that restricts animations // to 30-40 fps. if (window.mozRequestAnimationFrame) &#123; // Check the Gecko version. Gecko is used by browsers // other than Firefox. Gecko 2.0 corresponds to // Firefox 4.0. index = userAgent.indexOf('rv:'); if (userAgent.indexOf('Gecko') != -1) &#123; geckoVersion = userAgent.substr(index + 3, 3); if (geckoVersion === '2.0') &#123; // Forces the return statement to fall through // to the setTimeout() function. window.mozRequestAnimationFrame = undefined; &#125; &#125; &#125; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) &#123; var start, finish; window.setTimeout(function() &#123; start = +new Date(); callback(start); finish = +new Date(); self.timeout = 1000 / 60 - (finish - start); &#125;, self.timeout); &#125;; &#125;)();","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"[Java LeetCode]35. Search Insert Position","slug":"leetcode-search-insert-position","date":"2019-01-11T01:59:35.000Z","updated":"2019-01-14T01:12:21.989Z","comments":true,"path":"front-end/leetcode-search-insert-position-1547171975.html","link":"","permalink":"https://haohaio.github.io/front-end/leetcode-search-insert-position-1547171975.html","excerpt":"","text":"原题链接 Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5Output: 2 Example 2: Input: [1,3,5,6], 2Output: 1 Example 3: Input: [1,3,5,6], 7Output: 4 Example 4: Input: [1,3,5,6], 0Output: 0 解法类似二分查找法 class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int startIndex = 0; int endIndex = nums.length - 1; while (startIndex &lt;= endIndex) &#123; int midIndex = (startIndex + endIndex) / 2; if (target &lt;= nums[midIndex]) &#123; endIndex = midIndex - 1; &#125; else &#123; startIndex = midIndex + 1; &#125; &#125; return startIndex; &#125;&#125;","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[Java LeetCode]28. Implement strStr()","slug":"leetcode-implement-indexof-func","date":"2019-01-10T08:42:39.000Z","updated":"2019-01-10T09:03:12.227Z","comments":true,"path":"front-end/leetcode-implement-indexof-func-1547109759.html","link":"","permalink":"https://haohaio.github.io/front-end/leetcode-implement-indexof-func-1547109759.html","excerpt":"","text":"原题链接 Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2 Example 2: Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1 Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strStr() and Java’s indexOf()). 解法遍历即可。 class Solution &#123; public int strStr(String haystack, String needle) &#123; int len1 = haystack.length(); int len2 = needle.length(); if (len1 &lt; len2) &#123; return -1; &#125; for (int i = 0; ; i++) &#123; if (i + len2 &gt; len1) &#123; return -1; &#125; for (int j = 0; ; j++) &#123; // 当相同的字符串长度等于子串的长度时，返回主串的长度即可 if (j == len2) &#123; return i; &#125; if (haystack.charAt(i + j) != needle.charAt(j)) &#123; break; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"浅谈移动端H5页面的适配方案","slug":"html5-layout","date":"2019-01-07T10:10:11.000Z","updated":"2019-01-10T08:41:23.468Z","comments":true,"path":"front-end/html5-layout-1546855811.html","link":"","permalink":"https://haohaio.github.io/front-end/html5-layout-1546855811.html","excerpt":"","text":"由于现在的移动设备屏幕尺寸众多，所以要做好适配真的是一个让人头痛的问题。今天就来了解一下如何解决这个问题。 在介绍方案之前，我们要首先要对 viewport 的 meta 标签有一个大概的了解，其主要用来告诉浏览器如何规范的渲染 Web 页面。我们经常可以在页面中看到这样的代码： &lt;!-- 将视窗的宽度设置为设备宽度。网页不缩放，不允许用户缩放。页面占满整个屏幕 (适配“刘海”屏)。--&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover\"/&gt; 方案一：浏览器自动缩放首先来介绍一种最简单粗暴的一种解决方案： 假如我们设计稿的宽度是 750px, 那么我们可以将 viewport 的 meta 标签设置为这个样子： &lt;!-- 将视窗的宽度设置为 750px --&gt;&lt;meta name=\"viewport\" content=\"width=750\"&gt; 然后写 CSS 样式关于尺寸的值时，所有的值都保持与设计稿的大小一致，这样我们就可以适配各个不同尺寸的设备啦~~ 不信的话，可以复制代码在浏览器里悄悄： &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=750\"&gt; &lt;title&gt;固定视窗宽度，浏览器自动缩放&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; &#125; div &#123; height: 80px; line-height: 80px; margin-bottom: 80px; background: #000; color: #fff; font-size: 48px; text-align: center; &#125; #first &#123; width: 400px; &#125; #second &#123; width: 600px; &#125; #third &#123; width: 750px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"first\"&gt;400px&lt;/div&gt; &lt;div id=\"second\"&gt;600px&lt;/div&gt; &lt;div id=\"third\"&gt;750px&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这种做法，就是将视窗设置成固定的宽度，让浏览器自动缩放进行适配。但这种做法有一个很明显的弊端，就是不支持媒体查询，当我们需要跟聚设备宽度做一些样式的定制时，这种方案就做不到了。其原因就是我们将视窗设置成了固定的宽度，媒体查询时获得的宽度始终都是 750px 了。。。 简单来说，当我们的页面没有那么精致的时候，这种方案就可以满足我们的要求了~~ 方案二：动态设置缩放比例此外，我们还可以将视窗的宽度设为 device-width，动态设置缩放比例来进行适配。但这种方案其实与方案一是一样的，还是不支持媒体查询。因为缩放也会影响视窗的尺寸。这种方案相对于方案一来说，兼容性可能会更好一点，但具体兼容性没有进行测试，不太清楚~~ 动态设置缩放比例的代码如下： var resizeEvt = 'onorientationchange' in window ? 'orientationchange' : 'resize';var recalc = function() &#123; var metaEl = document.querySelector('meta[name=\"viewport\"]'); var designWidth = 750; // 设计稿的宽度 var scale = document.documentElement.clientWidth / designWidth; // 视窗宽度与设计稿宽度的比例 if (!metaEl) &#123; metaEl = document.createElement('meta'); metaEl.setAttribute('name', 'viewport'); metaEl.setAttribute('content', 'width=device-width, initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no', 'viewport-fit=cover'); document.documentElement.firstElementChild.appendChild(metaEl); &#125; else &#123; metaEl.setAttribute('content', 'width=device-width, initial-scale=' + scale + ', minimum-scale=' + scale + ', maximum-scale=' + scale + ', user-scalable=no', 'viewport-fit=cover'); &#125;&#125;;if (document.addEventListener) &#123; // 监听屏幕旋转事件 window.addEventListener(resizeEvt, recalc, false); // 监听 dom 内容加载完毕事件 document.addEventListener('DOMContentLoaded', recalc, false);&#125; document.documentElement.clientWidth 还是始终都是 750px。 方案三：使用 rem 进行布局有时为了让页面更加精致，我们还是不能将视窗设置成固定的宽度。一般情况下，我们通过设置告诉浏览器使用它的理想视口，即将视窗的宽度设为设备的宽度，并不进行缩放： 苹果引入了理想视口的概念，它是对设备来说最理想的布局视口尺寸。理想视口中的网页用户最理想的宽度，用户进入页面的时候不需要缩放。 &lt;!-- 解决各种浏览器兼容问题的 理想视口 设置 --&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; CSS3 引入了 rem，rem 是一种 CSS 单位。简单来讲 rem 就是相对于根元素 &lt;html&gt; 的 font-size 来计算尺寸大小。 /* 设置根元素 html 的 font-size 为 16px */html &#123; font-size: 16px;&#125;/* 相对于根元素字体大小，所以为 32px */p &#123; font-size: 2rem;&#125; 基于此，我们可以使用 rem 布局来解决移动端 H5 页面的适配问题。即把与元素尺寸有关的 CSS 属性都以 rem 作为单位，通过计算为不同设备的根元素设置不同的 fontSize，这样页面在不同设备下就能保持一致的网页布局。 动态设置根元素的 fontSize 大小的代码简单如下： var docEl = document.documentElement; // 获取根元素，即 &lt;html&gt; 元素var designWidth = 750; // 设计稿的宽度var baseFontSize = 100; // 写代码时所基于的根元素的 fontsize 大小。为了便于计算，设为 100var resizeEvt = 'onorientationchange' in window ? 'orientationchange' : 'resize';// 重新计算根元素的 fontsizevar recalc = function () &#123; var clientWidth = docEl.clientWidth; // 视窗宽度，即 viewport 的 meta 标签中 width 所设置的值 (device-width) * 缩放比例 if (clientWidth) &#123; docEl.style.fontSize = baseFontSize * (clientWidth / designWidth) + 'px'; &#125;&#125;;if (document.addEventListener) &#123; // 监听屏幕旋转事件 window.addEventListener(resizeEvt, recalc, false); // 监听 dom 内容加载完毕事件 document.addEventListener('DOMContentLoaded', recalc, false);&#125; 此外，我们还可以通过 CSS 预处理器来帮助我们将设计稿中的 px 转为 rem，比如在 sass 中封装一个方法： $base-font-size: 100;// 计算 px 转 rem@function px2rem($px) &#123; @return $px / $base-font-size * 1rem&#125; 方案四：使用 vw 进行布局vw 是基于Viewport视窗的长度单位，这里的视窗（Viewport）指的就是浏览器可视化的区域，而这个可视区域是 window.innerWidth/window.innerHeight 的大小。 vw：是 Viewport’s width 的简写，1vw 等于 window.innerWidth的1% vh：和 vw 类似，是Viewport’s height的简写，1vh 等于window.innerHeihgt的1% vmin：vmin的值是当前 vw 和 vh 中较小的值 vmax：vmax的值是当前 vw 和 vh 中较大的值 假如我们设计稿的宽度是 750px, 那么 1vw 就是 7.5px 我们依然是将 viewport 的 mate 标签设置为这个样子： &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; 我们直接将设计稿的中 px 换算成 vw 来设置样式后，就可以完成适配了，而不需要再像方案三中动态的修改 html 元素的 fontSize 了~~ 这种方案与方案三的方案思想是一致的，都是进行等比例缩放。相对于方案三来说，这种方案兼容性较差一些，\b但网上也有一些方法来处理这问题，这里就不详细介绍了。。。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"HTML5","slug":"html5","permalink":"https://haohaio.github.io/tags/html5/"}]},{"title":"[Java LeetCode]27. Remove Element","slug":"leetcode-remove-element","date":"2019-01-03T15:23:03.000Z","updated":"2019-01-10T09:03:30.620Z","comments":true,"path":"leetcode/leetcode-remove-element-1546528983.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-remove-element-1546528983.html","excerpt":"","text":"原题链接 Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example 1: Given nums = [3,2,2,3], val = 3,Your function should return length = 2, with the first two elements of nums being 2.It doesn&apos;t matter what you leave beyond the returned length. Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2,Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.Note that the order of those five elements can be arbitrary.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy)int len = removeElement(nums, val);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解法class Solution &#123; public int removeElement(int[] nums, int val) &#123; int newLength = 0; int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; if (nums[i] != val) &#123; nums[newLength] = nums[i]; newLength++; &#125; &#125; return newLength; &#125;&#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"使用 Docker 搭建 MySQL 服务","slug":"docker-mysql","date":"2019-01-03T01:45:56.000Z","updated":"2019-01-03T07:27:25.582Z","comments":true,"path":"others/docker-mysql-1546479956.html","link":"","permalink":"https://haohaio.github.io/others/docker-mysql-1546479956.html","excerpt":"","text":"最近在学习 Spring Boot 的时候，需要搭建一个 mysql 的服务，我们可以通过 docker 非常方便地搭建一个 mysql 服务。只需一个命令： # 默认使用 mysql:@latest 镜像，若未安装会自动下载$ docker run --name mysql-dev -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql –-name：给新创建的容器命名，此处命名为 mysql-dev -e：配置信息，此处配置 mysql 的 root 用户的登陆密码 -p：端口映射，此处映射主机 3306 端口到容器 mysql-dev 的 3306 端口 -d：成功启动容器后输出容器的 ID mysql 的服务已经搭好了。 可以通过 docker 连接上 mysql 服务，进行其它一些操作 # 登录容器$ docker exec -it mysql-dev bash# 连接 mysql 服务 (-p后面没有空格。第一次连接时会提示在命令行界面上直接使用密码不安全)$ mysql -p123456 # 创建一个数据库 db_examplemysql&gt; create database db_example;# 创建用户mysql&gt; create user 'springuser'@'%' identified by 'ThePassword';# 给 springuser 用户 db_example 的所有权限mysql&gt; grant all on db_example.* to 'springuser'@'%'; Tips发现使用可视化工具 (笔者用的 Navicat) 连接 mysql 服务时，会报 Authentication plugin &#39;caching_sha2_password&#39; cannot be loaded 错误。是因为新版本的 mysql 加密方式改了, 而当前可视化工具还不支持。所以我们先通过修改密码将加密方式改为以前的加密方式： mysql&gt; ALTER USER 'root' IDENTIFIED WITH mysql_native_password BY '123456';","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://haohaio.github.io/tags/docker/"}]},{"title":"Canvas学习笔记六：绘制仪表盘","slug":"canvas-dashboard","date":"2019-01-02T02:02:05.000Z","updated":"2019-01-02T08:41:45.005Z","comments":true,"path":"front-end/canvas-dashboard-1546394525.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-dashboard-1546394525.html","excerpt":"","text":"基于之前所学的关于 Canvas 的知识，来完成一个综合实例，绘制一个刻度仪表盘。 一、绘制网格线function drawGrid(color, stepX, stepY) &#123; context.save(); context.strokeStyle = color; context.lineWidth = 0.5; for (var i = stepX + 0.5; i &lt; context.canvas.width; i += stepX) &#123; context.beginPath(); context.moveTo(i, 0); context.lineTo(i, context.canvas.height); context.stroke(); &#125; for (var i = stepY + 0.5; i &lt; context.canvas.height; i += stepY) &#123; context.beginPath(); context.moveTo(0, i); context.lineTo(context.canvas.width, i); context.stroke(); &#125;&#125;drawGrid('lightgray', 10, 10); 二、绘制仪表盘中心圆点function drawCentroid() &#123; context.beginPath(); context.save(); context.strokeStyle = 'rgba(0, 0, 0, .5)'; context.fillStyle = 'rgba(80, 190, 240, .6)'; context.arc(canvas.width / 2, canvas.height / 2, 10, 0, Math.PI * 2, false); context.stroke(); context.fill(); context.restore();&#125; 三、绘制仪表盘指针function drawCentroidGuidewire() &#123; // 计算得到刻度指示点坐标 var angle = -Math.PI / 4; var radius = 205; var endPoint = &#123; x: canvas.width / 2 + radius * Math.cos(angle), y: canvas.height / 2 + radius * Math.sin(angle) &#125;; context.save(); context.strokeStyle = 'goldenrod'; context.fillStyle = 'rgba(250, 250, 0, 0.6)'; // 绘制刻度指示点 context.beginPath(); context.strokeStyle = 'rgba(100, 140, 230, 0.9)'; context.arc(endPoint.x, endPoint.y, 5, 0, Math.PI * 2, false); context.fill(); context.stroke(); // 绘制中心原点与指示点连接线 context.beginPath(); context.moveTo(canvas.width / 2 , canvas.height / 2); context.lineTo(endPoint.x, endPoint.y); context.stroke(); context.restore();&#125; 四、绘制外层圆圈function drawRing() &#123; drawRingOuterCircle(); context.strokeStyle = 'rgba(0, 0, 0, .1)'; context.arc(canvas.width / 2, canvas.height / 2, 185, 0, Math.PI * 2, false); context.fillStyle = 'rgba(100, 140, 230, .1)'; context.fill(); context.stroke();&#125;function drawRingOuterCircle() &#123; context.shadowColor = 'rgba(0, 0, 0, .7)'; context.shadowOffsetX = 3; context.shadowOffsetY = 3; context.shadowBlur = 6; context.strokeStyle = 'rgba(100, 140, 230, .5)'; context.beginPath(); context.arc(canvas.width / 2, canvas.height / 2, 205, 0, Math.PI * 2, true); context.stroke();&#125; 五、绘制内层圆function drawTickInnerCircle() &#123; context.sava(); context.beginPath(); context.strokeStyle = 'rgba(0, 0, 0, .1)'; context.arc(canvas.width / 2, canvas.height / 2, 175, 0, Math.PI * 2, false); context.stroke(); context.restore();&#125; 六、绘制刻度线function drawTicks() &#123; context.save(); for (var angle = 0, cnt = 0; angle &lt; Math.PI * 2; angle += Math.PI / 64, cnt++) &#123; drawTick(angle, 185, cnt++); &#125; context.restore();&#125;function drawTick(angle, radius, cnt) &#123; context.beginPath(); var tickWidth = cnt % 4 === 0 ? 10 : 5; context.moveTo(canvas.width / 2 + Math.cos(angle) * (radius - tickWidth), canvas.height / 2 + Math.sin(angle) * (radius - tickWidth)); context.lineTo(canvas.width / 2 + Math.cos(angle) * (radius), canvas.height + Math.sin(angle) * (radius)); context.strokeStyle = 'rgba(100, 140, 230, 0.7)'; context.stroke();&#125; 七、绘制标注function drawAnnotations() &#123; context.save(); context.fillStyle = 'rgba(0, 0, 230, 0.9)'; context.font = '12px Helvetica'; for (var angle = 0; angle &lt; 2 * Math.PI; angle += Math.PI / 8) &#123; context.beginPath(); context.fillText((angle * 180 / Math.PI).toFixed(0), canvas.width / 2 + Math.cos(angle) * (185 - 10 * 2), canvas.height / 2 - Math.sin(angle) * (185 - 10 * 2)); &#125; context.restore();&#125;","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Canvas学习笔记五：线段","slug":"canvas-line","date":"2018-12-29T03:01:09.000Z","updated":"2019-01-02T01:48:58.813Z","comments":true,"path":"front-end/canvas-line-1546052469.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-line-1546052469.html","excerpt":"","text":"Canvas 绘图环境提供了两个可以用来创建线段的方法： moveTo(x, y)向当前路径增加一条子路径，该子路径只包含一个点，就是参数传入的点。 lineTo(x, y)若当前路径没有子路径，那么这个方法就与 moveTo() 方法一样。如果当前路径中存在子路径，那么该方法会将会将参数传入的点加入到子路径中。 绘制线段时还是需要创建完路径后，调用 stroke() 方法才能绘制。 线段与像素边界 如果在像素边界绘制一条 1 像素宽的线段，那么 Canvas 的绘图环境对象会试着将分别将半个像素画在边界中线的两边。然而，在一个整像素范围内，绘制半个像素宽的像素是不可能的，所以边界两个方向的半个像素都被扩展为一个像素。所以最后绘制的线段宽度为 2 个像素。 如果将线段绘制在一个像素的中间，那么刚好绘制的就是 1 像素宽的线段。 示例 线段端点的绘制我们可以是使用 Canvas 绘图环境的 lineCap 属性来控制线段端点的绘制。可取值为： butt：默认值，无特殊处理。 round：在端点处多画一个半圆，其半径等于线宽的一半。 square：在端点处多画一个矩形，长度与线宽一致，宽度等于线宽的一半。 线段连接点的绘制我们可以是使用 Canvas 绘图环境的 lineJoin 属性来控制线段连接点的绘制。可取的值：bevel, round, miter，默认值是 miter，具体如下图所示： 当取值为 miter 时，还可以指定一个 miterLimit 属性，它表示对斜接线的长度与二分之一线宽的比值做出限制处理。 斜接线指的是在两条线交汇处内角和外角之间的距离。 若比值超过了设置的限制值，浏览器就会以 bevel 的方式来绘制线段的连接点。默认值为 10.0。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"[Java LeetCode]26. Remove Duplicates From Sorted Array","slug":"leetcode-remove-duplicates-from-sorted-array","date":"2018-12-29T02:02:51.000Z","updated":"2019-01-10T09:03:50.056Z","comments":true,"path":"leetcode/leetcode-remove-duplicates-from-sorted-array-1546048971.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-remove-duplicates-from-sorted-array-1546048971.html","excerpt":"","text":"原题链接 Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解法用一个 temp 变量记录要返回的长度，遍历数组时，如果后面的元素和前面的元素不同，就让 temp 变量加 1，最后返回 temp 即可。 class Solution &#123; public int removeDuplicates(int[] nums) &#123; int len = nums.length; if (len &lt;= 1) &#123; return len; &#125;; int temp = 1; for (int i = 1; i &lt; len; i++) &#123; if (nums[i - 1] != nums[i]) &#123; nums[temp] = nums[i]; temp++; &#125; &#125; return temp; &#125;&#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[Java LeetCode]21. Merge Two Sorted Lists","slug":"leetcode-merge-two-sorted-lists","date":"2018-12-27T13:11:26.000Z","updated":"2019-01-11T03:01:42.697Z","comments":true,"path":"leetcode/leetcode-merge-two-sorted-lists-1545916286.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-merge-two-sorted-lists-1545916286.html","excerpt":"","text":"原题链接 Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解法首先要对 ListNode 有一定的了解： ListNode 存储了两个变量：val 和 next。val 是这个节点的值，next 是指向下一节点的指针，当 next 为空指针时，这个节点是链表的最后一个节点。 class ListNode &#123; int val; // 当前指针的值 ListNode next; // 下一个节点 ListNode(int x)&#123; val = x; next = null; &#125;&#125; 新链表指针每次指向值小的节点，依次比较下去，最后，当其中一个链表到达了末尾，我们只需要把新链表指针指向另一个没有到末尾的链表此时的指针即可。 class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); ListNode temp = head; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt; l2.val) &#123; temp.next = l1; l1 = l1.next; &#125; else &#123; temp.next = l2; l2 = l2.next; &#125; temp = temp.next; &#125; temp.next = l1 != null ? l1 : l2; return head.next; &#125;&#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[Java LeetCode]20. Vaild Parentheses","slug":"leetcode-vaild-parentheses","date":"2018-12-26T14:32:30.000Z","updated":"2019-01-03T14:59:00.264Z","comments":true,"path":"leetcode/leetcode-vaild-parentheses-1545834750.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-vaild-parentheses-1545834750.html","excerpt":"","text":"原题链接 Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: Input: &quot;()&quot;Output: true Example 2: Input: &quot;()[]&#123;&#125;&quot;Output: true Example 3: Input: &quot;(]&quot;Output: false Example 4: Input: &quot;([)]&quot;Output: false Example 5: Input: &quot;&#123;[]&#125;&quot;Output: true 解法一通过观察发现，在合法的情况下，当遇到第一个右括号时，其前面紧邻的一个括号必定是和其匹配的左括号。那么我们可以用栈来解决这个问题，当出现左括号的时候入栈，当遇到右括号时，判断栈顶的左括号是否和其匹配，匹配的话出栈，不匹配的话直接返回 false 即可。最终判断是否空栈即可。 class Solution &#123; public boolean isValid(String s) &#123; HashMap&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;(); map.put(')', '('); map.put(']', '['); map.put('&#125;', '&#123;'); Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (map.containsKey(c)) &#123; char topElement = stack.empty() ? '#' : stack.pop(); if (topElement != map.get(c)) &#123; return false; &#125; &#125; else &#123; stack.push(c); &#125; &#125; return stack.isEmpty(); &#125;&#125; 解法二用数字的 ++ 和 --模拟栈的操作使其操作更快。有个细节注意下 top = 1;，从而省去了之后判空的操作和 top - 1 导致数组越界的错误。 class Solution &#123; public boolean isValid(String s) &#123; // HashMap&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;(); // map.put(')', '('); // map.put(']', '['); // map.put('&#125;', '&#123;'); int top = 1; char[] stack = new char[s.length() + top]; for (char c : s.toCharArray()) &#123; // if (map.containsKey(c)) &#123; // if (stack[--top] != map.get(c)) &#123; // return false; // &#125; // &#125; else &#123; // stack[top++] = c; // &#125; if (c == '(' || c == '[' || c == '&#123;') &#123; stack[top++] = c; &#125; else if (c == ')' &amp;&amp; stack[--top] != '(') &#123; return false; &#125; else if (c == ']' &amp;&amp; stack[--top] != '[') &#123; return false; &#125; else if (c == '&#125;' &amp;&amp; stack[--top] != '&#123;') &#123; return false; &#125; &#125; return top == 1; &#125;&#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[Java LeetCode]14. Longest Common Prefix","slug":"leetcode-longest-common-prefix","date":"2018-12-26T01:23:16.000Z","updated":"2019-01-03T14:58:16.447Z","comments":true,"path":"leetcode/leetcode-longest-common-prefix-1545787396.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-longest-common-prefix-1545787396.html","excerpt":"","text":"原题链接 Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”. Example 1: Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Example 2: Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. 解法一暴力破解。 class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) &#123; return \"\"; &#125;; String prefix = strs[0]; int len = strs.length; for (int i = 1; i &lt; len; i++) &#123; // prefix 不是当前项的前缀时 while (strs[i].indexOf(prefix) != 0) &#123; prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) &#123; return \"\"; &#125; &#125; &#125; return prefix; &#125;&#125; 解法二相对于解法一，使用垂直扫描进行优化。并取字符串数组中最短字符串的长度，以减少嵌套遍历次数。 class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) &#123; return \"\"; &#125;; int minLen = Integer.MAX_VALUE; for (String str : strs) &#123; minLen = Math.min(minLen, str.length()); &#125; for (int i = 0; i &lt; minLen; i++)&#123; char c = strs[0].charAt(i); for (int j = 1; j &lt; strs.length; j ++) &#123; if (strs[j].charAt(i) != c) &#123; return strs[0].substring(0, i); &#125; &#125; &#125; return strs[0].substring(0, minLen); &#125;&#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[Java LeetCode]13. Roman to Integer","slug":"leetcode-roman-to-integer","date":"2018-12-24T01:40:46.000Z","updated":"2019-01-03T14:58:45.901Z","comments":true,"path":"leetcode/leetcode-roman-to-integer-1545615646.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-roman-to-integer-1545615646.html","excerpt":"","text":"原题链接 Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: &quot;III&quot;Output: 3 Example 2: Input: &quot;IV&quot;Output: 4 Example 3: Input: &quot;IX&quot;Output: 9 Example 4: Input: &quot;LVIII&quot;Output: 58Explanation: L = 50, V = 30 and III = 3. Example 5: Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 解法可以看到罗马数字的计数机制中，小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数。其它情况都是数字相加即可。那么我们可以利用 HashMap 来完成罗马数字的 7 个数字符号与整数的映射关系，然后对字符串逆向遍历，处理得到结果。代码如下： class Solution &#123; public int romanToInt(String s) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int len = s.length(); int sum = map.get(s.charAt(len - 1)); for (int i = len - 2; i &gt;= 0; i--) &#123; if (map.get(s.charAt(i)) &lt; map.get(s.charAt(i + 1))) &#123; sum -= map.get(s.charAt(i)); &#125; else &#123; sum += map.get(s.charAt(i)); &#125; &#125; return sum; &#125;&#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"Canvas学习笔记四：路径","slug":"canvas-path","date":"2018-12-22T09:05:30.000Z","updated":"2018-12-26T14:12:32.926Z","comments":true,"path":"front-end/canvas-path-1545469530.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-path-1545469530.html","excerpt":"","text":"除了绘制矩形的两个 API 外，Canvas 的绘图环境还提供了其它一些方法用于绘制更加复杂的图形。这些方法都是基于路径 (path) 的。 图形路径 (rect &amp; arc)我们可以先看一个使用 context 提供的 API 绘制简单图形路径 (矩形和圆弧) 的基本示例：Canvas Path 通过示例，我们可以看到绘制图形的基本步骤如下： context 调用 beginPath() 方法来开始一段新的路径。 context 使用 rect() 或 arc() 方法分别创建矩形及弧形路径。 rect() 方法创建的路径是封闭的。 arc() 方法创建的路径，是不封闭的。除非是个圆形路径。可调用 closePath() 方法封闭路径。 context 调用 stroke() 或 fill() 方法，对路径进行描边或填充。 其中对 arc() 方法进行一下详细介绍： /** * x: 圆的中心的 x 坐标 * y: 圆的中心的 y 坐标 * radii: 圆的半径 * startAngle: 起始角，以弧度计。 (弧的圆形的三点钟位置是 0 度) * endAngle: 结束角，以弧度计。 * counterclockwise: 规定应该逆时针还是顺时针绘图。false = 顺时针，true = 逆时针。默认值为 false。 */arc(x, y, radii, startAngle, endAngle, counterclockwise) rect() 方法绘制路径时，总是顺时针方向的。(我们可以自定义方法来支持逆时针方向绘制矩形路径) 子路径Canvas 之中只能有一条路径存在，Canvas 规范将其称为 “当前路径”（current path）。然而，这条路径可以包含许多子路径（subpath）。而子路径是由两个或更多的点组成的。 如果在当前路径中存在子路径的情况下调用 arc() 方法, 那么此方法就会从子路径的终点向圆弧的起点画一条线。 填充路径时的 “非零环绕规则” (nonzero winding rule)如果当前路径是循环的，或是包含多个相交的子路径，那么 Canvas 的绘图环境就需要判断，当 fill() 方法被调用时，应该如何进行填充。Canvas 是使用 “非零环绕规则” 来进行判断的： 对于路径中任意指定区域，从该区域内部画一条足够长的线段，使此线段的完全落在路径范围之外。 然后，将计数器初始化为 0，每当这个线段与路径上的直线或曲线相交时，就改变计数器的值，如果是与路径顺时针相交时，那么计数器就加 1， 如果是与路径逆时针相交时，那么计数器就减 1。 如果计数器最终值不是 0，那么此区域就在路径范围里面，在调用 fill() 方法时，浏览器就会对其进行填充。如果最终值是 0，那么此区域就不在路径范围内，浏览器就不会对其进行填充。 具体情况如图所示：","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"[Java LeetCode]9. Palindrome Number","slug":"leetcode-palindrome-number","date":"2018-12-22T02:19:46.000Z","updated":"2019-01-03T14:58:05.031Z","comments":true,"path":"leetcode/leetcode-palindrome-number-1545445186.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-palindrome-number-1545445186.html","excerpt":"","text":"原题链接 Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121Output: true Example 2: Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? 解法一题意是判断一个有符号整型数是否是回文，即逆序过来的整数和原整数相同。则负数肯定不是，非 0 的 10 的倍数的数也不是。那就把数字进行反转进行比较就可得出结果。代码如下： class Solution &#123; public boolean isPalindrome(int x) &#123; if(x &lt; 0 || (x != 0 &amp;&amp; x % 10 == 0)) &#123; return false; &#125; int copyX = x; int revertedNumber = 0; while (copyX != 0) &#123; revertedNumber = revertedNumber * 10 + copyX % 10; copyX /= 10; &#125; return x == reverse; &#125;&#125; 解法2但其实我们不需要将数字完全反转进行比对，只需要将数字反转一半进行然后与前面一半的数字进行比对即可。代码如下： class Solution &#123; public boolean isPalindrome(int x) &#123; if(x &lt; 0 || (x != 0 &amp;&amp; x % 10 == 0)) &#123; return false; &#125; int revertedNumber = 0; while (x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; &#125; return x == revertedNumber || x == revertedNumber / 10; &#125;&#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[Java LeetCode]7. Reverse Integer","slug":"leetcode-reverse-integer","date":"2018-12-21T15:08:32.000Z","updated":"2019-01-03T14:58:40.913Z","comments":true,"path":"leetcode/leetcode-reverse-integer-1545404912.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-reverse-integer-1545404912.html","excerpt":"","text":"原题链接 Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123Output: 321 Example 2: Input: -123Output: -321 Example 3: Input: 120Output: 21 Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 解法： 对数字进行反转的方法如下 int pop = x % 10;x /= 10;int rev = 0;rev = rev * 10 + pop; 在32位的机器上，Integer 的取值范围为 [-2^31, 2^31 -1], 即 [-2147483648, 2147483647]。所以最后反转的结果有可能会超出取值范围，需要进行特殊处理。 代码如下： class Solution &#123; public int reverse(int x) &#123; int rev = 0; while (x != 0) &#123; int pop = x % 10; x /= 10; // Integer.MAX_VALUE = 2147483647 if (rev &gt; Integer.MAX_VALUE / 10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) &#123; return 0; &#125;; // Integer.MIN_VALUE = -2147483648 if (rev &lt; Integer.MIN_VALUE / 10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) &#123; return 0; &#125;; rev = rev * 10 + pop; &#125; return rev; &#125;&#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[Java LeetCode]1. Two Sum","slug":"leetcode-two-sum","date":"2018-12-21T13:24:11.000Z","updated":"2019-01-03T14:58:55.011Z","comments":true,"path":"leetcode/leetcode-two-sum-1545398651.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-two-sum-1545398651.html","excerpt":"","text":"原题链接 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 解法一：暴力解决，循环两次搞定。 public int[] twoSum(int[] nums, int target) &#123; int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; for (int j = i + 1; j &lt; len; j++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[] &#123; i, j &#125;; &#125; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; 解法二：利用 HashMap 作为存储，key 为当前元素值，value 为当前元素值的索引。遍历时判断 map 中是否存在 key 加上当前元素值可以等于目标值，如果存在，就证明 key 为第一个值，当前元素值为第二个值，各自取其索引即可。 维护数组中每个元素到其索引的映射的最佳方法是就是哈希表。 public int[] twoSum(int[] nums, int target) &#123; int len = nums.length; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; len; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[]&#123;map.get(complement), i&#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"CSS颜色值之HSL","slug":"CSS颜色值之HSL","date":"2018-12-20T10:01:17.000Z","updated":"2018-12-22T09:23:32.851Z","comments":true,"path":"front-end/css-color-hsl-1545300077.html","link":"","permalink":"https://haohaio.github.io/front-end/css-color-hsl-1545300077.html","excerpt":"","text":"CSS3 的 HSL 方法已经被现代浏览器广泛的支持，但在日常开发中还是很少使用，今天我们就来简单了解一下，示例代码如下： .test &#123; background-color: hsl(360, 50%, 50%);&#125; IE8 以及更早的版本不支持使用 HSL 设置颜色值。 RGB vs HSLCSS3 颜色规范中说到，之所以要增加对 HSL 格式的支持，是因为以 RGB 方式来指定颜色，主要有两个缺陷： 它是以硬件为导向的。这种表述颜色的形式，是基于“阴极射线管”的； 它不直观。 HSL 的 取值 H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360 S：Saturation(饱和度)。取值为：0.0% - 100.0% L：Lightness(亮度)。取值为：0.0% - 100.0% HSL颜色当然可以转换为 RGB颜色 或 HEX颜色。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Docker 入门","slug":"Docker入门","date":"2018-12-19T13:47:46.000Z","updated":"2018-12-20T11:07:53.324Z","comments":true,"path":"others/docker-introduction-1545227266.html","link":"","permalink":"https://haohaio.github.io/others/docker-introduction-1545227266.html","excerpt":"","text":"简介Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 Docker 系统有两个程序：Docker 服务端 和 Docker 客户端。 Docker 服务端是一个服务进程，管理着所有的容器。 Docker 客户端则扮演着 Docker 服务端的远程控制器，可以用来控制 Docker 的服务端进程。 大部分情况下，Docker 服务端和客户端运行在一台机器上。 # 查看 docker 版本$ docker version 虚拟机 VS Linux 容器Linux 容器与虚拟机享有相似的资源隔离和分配，但是两者还是有很大区别的。 虚拟机可以在一种操作系统里面运行另一种操作系统。看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。Linux 容器是 Linux 的一种虚拟化技术。它不是模拟一个完整的操作系统，而是对进程进行隔离。 由于 Linux 容器是进程级别的，相比虚拟机有很多优势： 启动快 (启动虚拟机就相当于启动操作系统) 资源占用少 (虚拟机会独占一部分内存和硬盘空间) 体积小 Docker Image An image is a lightweight, stand-alone, executable package that includes everything needed to run a piece of software, including the code, a runtime, libraries, environment variables, and config files. 只读模板，包含一个基本的操作系统。 # 搜索可用镜像$ docker search tutorial# 下载镜像（用户名/镜像名:标签名）默认标签为 lastest$ docker pull learn/tutorial# 利用该镜像创建一个容器，执行完成会进入 bash 界面，输入 exit 可退出$ docker run -it learn/tutorials bash# 查看所有镜像$ docker images# 删除镜像（需先删除使用镜像的容器，使用 -f 参数强制删除(不推荐)）$ docker rmi 镜像名/镜像id Docker container A container is a runtime instance of an image. 一个轻量级的沙箱，容器是从镜像创建的，应用的运行实例。可以启动、开始、停止和删除，容器彼此间相互隔离。 # 创建容器# -i：让容器的标准输入保持打开; -t：让docker分配一个伪终端(pseudo-tty)，并绑定到容器的标准输入上。即允许用户交互$ docker create -it --name ubuntu-demo ubuntu:16.04# 启动容器$ docker start 容器名/容器id# 查看正在运行的容器列表$ docker ps# 查看所有容器列表$ docker ps -a# 查看刚刚操作的容器id$ docker ps -l# 新建并启动容器 (docker run = docker create + docker start)(-d：后台运行)$ docker run -it ubuntu:16.04 /bin/bash# run 命令后可跟在镜像中运行的命令# 使用 Ubuntu 的 apt-get 命令来安装 ping 程序# 在执行 apt-get 命令的时候，要带上 -y 参数。如果不指定 -y 参数的话，apt-get 命令会进入交互模式，需要用户输入命令来进行确认，但在 Docker 环境中是无法响应这种交互的。$ docker run learn/tutorial apt-get install -y ping# 登录容器$ docker exec -it 容器名/容器id /bin/bash# 停止容器$ docker stop 容器名/容器id# 停止所有容器$ docker stop $(docker ps -a -q)# 删除容器$ docker rm 容器id（需先停止容器或者使用 -f）# 删除所有容器$ docker rm $(docker ps -a -q) Docker 数据管理# copy 本地文件到容器内$ docker cp ./index.html nginx-demo:/usr/share/nginx/html# Volume# 将本地的 ~/docker/nginx-demo 目录挂载到容器内部的 /usr/share/nginx/html$ docker run --name nginx-demo -v ~/docker/nginx-demo:/usr/share/nginx/html -d nginx Docker 端口映射在启动容器的时候，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。 # 将本地的 8001 端口映射到容器的 80 端口$ docker run --name nginx-demo -p 8001:80 -d nginx$ curl http://localhost:8001/# 查看容器端口映射情况$ docker port 容器名/容器id Docker 其它常用命令# 登录$ docker login -u 用户名 -p 密码# 发布镜像$ docker push 镜像名","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://haohaio.github.io/tags/docker/"}]},{"title":"Canvas学习笔记三：描边与填充","slug":"Canvas描边与填充","date":"2018-12-17T09:46:54.000Z","updated":"2019-01-02T02:00:59.345Z","comments":true,"path":"front-end/canvas-basic-drawing-1545040014.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-basic-drawing-1545040014.html","excerpt":"","text":"Canvas 的绘制操作主要分为两种：描边与填充。 坐标系统在进行绘制之前，我们还要先需要了解一下 Canvas 的坐标系统。只有先通过坐标确定了位置，Canvas 绘图环境才知道在哪里进行绘制。 在默认情况下，坐标系统是以 canvas 的左上角为原点，X 坐标向右方增长，Y 坐标向下方延伸。 但Canvas 的坐标系统并不是固定的，我们还可以对坐标系统进行平移、旋转、缩放等操作。这里先不做详细介绍 文本的绘制Canvas 的绘图环境提供了下面两个 API 来直接绘制文本： strokeText(string text, double x, double y) fillText(string text, double x, double y) 矩形的绘制Canvas 的绘图环境中仅有两个方法可以用来立即绘制图形 (其它都需要路径)，用于有关矩形的绘制： - strokeRect(double x, double y, double width, double height)- fillRect(double x, double y, double width, double height) 还有一个与矩形相关的 API，可用来清除矩形区域： - clearRect(double x, double y, double width, double height)\b 示例：Canvas Rect 描边与填充的样式 (strokeStyle &amp; fillStyle)颜色Canvas 默认使用的颜色为不透明的黑色。在绘制矩形的示例中通过 strokeStyle 属性修改的描边的颜色，通过 fillStyle 属性修改了填充的颜色。代码如下： // 设置描边颜色context.strokeStyle = 'red';// 设置填充颜色context.fillStyle = 'rgba(0, 0, 255, .5)'; 可看到左边矩形的边框遮盖了文本，这是因为边框用的是不透明色。 strokeStyle 与 fillStyle 的属性值可以是任意有效的 CSS 颜色字符串。可以用 RGB、RGBA、HSL、HSLA 以及十六进制 RGB 标注法来指定，还可以通过 ‘red’、‘yellow’ 这样的颜色名称来指定。 渐变色Canvas 元素支持线性 (linear) 渐变和放射 (radial) 渐变。 线性渐变我们可以通过 context 调用 createLinearGradient(double x1, double y1, double x2, double y2) 方法来创建线性渐变。需要向该方法传入两个点的 x、y 坐标，两点之间的连线就是 canvas 建立颜色渐变效果的依据。可通过该方法创建返回的 LinearGradient 实例调用 addColorStop(double stop, string color) 来向该渐变色添加颜色停止点。然后将该实例指定为 fillStyle 进行绘制。 示例：Canvas Linear Gradient 放射渐变我们可以通过 context 调用 createRadialGradient(double x1, double y1, double d1,double x2, double y2, double d2) 方法来创建放射渐变需要指定两个圆形 (x、y 指定圆心，d 指定半径)，它们表示某个圆锥的起止部位。该方法会返回一个 RadialGradient 实例。 示例：Canvas Radial Gradient 图案除了颜色和渐变色，Canvas 元素也允许使用图案来对图形和文本进行描边和填充。这里的图案可以是 image元素、canvas元素 或 video元素。 可以用 createPattern(pattern, string repetition) 来创建图案。第一个参数指定了图案所用的图像，第二个参数指定如何重复图案：repeat | repeat-x | repeat-y | no-repeat。 示例：Canvas Pattern","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Canvas学习笔记二：绘图环境","slug":"Canvas的绘图环境","date":"2018-12-17T07:33:17.000Z","updated":"2018-12-22T07:29:19.608Z","comments":true,"path":"front-end/canvas-context-1545031997.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-context-1545031997.html","excerpt":"","text":"canvas 元素仅仅是为了充当绘图环境对象的容器而存在的，该环境对象提供了全部的绘制功能。本篇文章我们只关注 2d 绘图环境。 2d 绘图环境Canvas 的 2d 绘图环境对象提供了功能强大的API，可以用来绘制图形与文本，显示并修改图像等等。本篇文章我们就对 canvas 绘图环境的属性和一些方法做一些简单的了解。 下表列出了绘图环境对象的所有属性： 属性 简介 canvas 指向绘图环境所属的canvas对象 fillstyle 指定该绘图环境在后续的图形填充操作中所使用的颜色，渐变色或方案 font 设定在调用绘图环境对象的 fillText() 或 strokeText() 方法时，所使用的字型 globalAlpha 全局透明度设定，取值范围 0~1.0 globalCompsiteOperation 将某个物体绘制在其他的物体之上时采用的绘制方式 lineCap 如何绘制线段的端点，可取的值：butt、round、square，默认值是 butt lineWidth 绘制线段的屏幕像素宽度。非负非无穷的 double 值，默认值是 1.0 lineJoin 在两条线段相交时如何绘制交点，可取的值：bevel, round, miter，默认值是 miter miterLimit 如何绘制 miter 形式的线段交点 shadowBlur 延伸的阴影效果，该值为高斯模糊方程式中的参数值，非负、非无穷的 double 值，默认值为 0 shadowColor 阴影的颜色值 shadowOffsetX 阴影效果的水平方向偏移量 shadowOffsetY 阴影效果的垂直方向偏移量 strokeStyle 对路径描边时所使用的绘制风格 textAlign fillText() 或 strokeText() 方法绘制的时候，所画文本的水平对齐方式 textBaseline fillText() 或 strokeText() 方法绘制的时候，所画文本的垂直对齐方式 此外，还有两个重要的方法，用来保存及恢复当前 canvas 绘图环境的所有属性： 方法 描述 save() 将当前 canvas 的状态推送到一个保存 canvas 状态的堆栈顶部 restore() 将 canvas 状态堆栈顶部的条目弹出。原来保存于栈顶的哪一组状态，在弹出之后，就被设置成 canvas 当前的状态了","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"使用 WePY 开发微信小程序","slug":"使用wepy开发微信小程序","date":"2018-12-17T02:10:45.000Z","updated":"2019-07-25T06:05:59.972Z","comments":true,"path":"front-end/hello-wepy-1545012645.html","link":"","permalink":"https://haohaio.github.io/front-end/hello-wepy-1545012645.html","excerpt":"","text":"项目搭建# 全局安装 WePY 命令行工具$ npm install wepy-cli -g# 使用 WePY 命令行工具新建一个 hello-wepy 项目$ wepy init standard hello-wepy# 安装依赖 &amp;&amp; 运行项目$ cd hello-wepy &amp;&amp; npm install &amp;&amp; npm run dev 开发工具微信开发者工具下载 微信开发者工具，安装成功后添加项目根目录为一个新项目即可。 根目录下有一个项目配置文件 - project.config.json，其中一些配置对应着微信开发者工具中的一些配置，需要注意一下 &#123; \"description\": \"project description\", \"setting\": &#123; \"urlCheck\": true, \"es6\": false, \"postcss\": false, \"minified\": false &#125;, \"compileType\": \"miniprogram\", \"appid\": \"touristappid\", \"projectname\": \"Project name\", \"miniprogramRoot\": \"./dist\"&#125; urlCheck：对应不检查安全域名选项，开启。 如果已配置好安全域名则建议关闭。 es6：对应关闭ES6转ES5选项，关闭。(未关闭会运行报错) postcss：对应关闭上传代码时样式自动补全选项，关闭。(某些情况下漏掉此项也会运行报错) minified：对应关闭代码压缩上传选项，关闭。(开启后，会导致真机 computed, props.sync 等等属性失效) 添加项目成功后，微信开发者工具展示如下： 使用 VS Code 进行开发推荐使用 VS Code 进行开发，可通过如下步骤来设置语法高亮： 在 Code 里先安装 Vue 的语法高亮插件 Vetur。 打开任意 .wpy 文件，点击右下角的选择语言模式，默认为纯文本；在弹出的窗口中选择 .wpy 的配置文件关联，在选择要与 .wpy 关联的语言模式中选择 Vue。 在 VS Code 编辑器设置中设置 settings.json，添加如下： &quot;files.associations&quot;: { &quot;*.wpy&quot;: &quot;vue&quot; }","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"微信小程序","slug":"mp-wechat","permalink":"https://haohaio.github.io/tags/mp-wechat/"}]},{"title":"Spring 之 IoC 简介","slug":"Spring之IoC简介","date":"2018-12-16T02:38:15.000Z","updated":"2018-12-18T02:21:36.836Z","comments":true,"path":"back-end/spring-ioc-1544927895.html","link":"","permalink":"https://haohaio.github.io/back-end/spring-ioc-1544927895.html","excerpt":"","text":"IoC (Inversion of Control)，中文通常翻译为“控制反转”。 好莱坞原则 “Don’t call us, we will call you.” 恰如其分地表达了“反转”的意味，是用来形容 IoC 最多的一句话。 为什么需要 IoC ？一般情况下，如果我们依赖于某个类或服务，最简单而有效的方式就是直接在类的构造函数中新建相应的依赖类。即我们自己主动地去获取依赖的对象。但其实我们最终要做的只是想要调用依赖对象的某项服务而已。只要用到这个依赖对象的时候，它能够准备就绪，我们完全可以不管这个对象是自己找来的还是别人送过来的。不需要自己去折腾。 实际上，IoC 就是为了帮助我们避免之前的“大费周折”，而提供了更加轻松简洁的方式。 IoC 的反转，就反转在让你从原来的事必躬亲，转变为现在的享受服务。简单点儿说，IoC 的理念就是，让别人为你服务! 通常情况下，被注入对象会直接依赖于被依赖对象。但是，在IoC的场景中，二者之间通过 IoC Service Provider 来打交道，所有的被注入对象和依赖对象现在由IoC Service Provider统一管理。 被注入对象需要什么，直接跟 IoC Service Provider 招呼一声，后者就会把相应的被依赖对象注入到被注入对象中，从而达到 IoC Service Provider 为被注入对象服务的目的。 IoC Service Provider 在这里就是通常的 IoC 容器所充当的角色。 从被注入对象的角度看，与之前直接寻求依赖对象相比，依赖对象的取得方式发生了反转，控制也从被注入对象转到了 IoC Service Provider 那里。 依赖注入 (Dependency Injection)IoC 和 依赖注入 其实是同一个概念的不同角度描述。IoC 是通过依赖注入实现的。相对 IoC 而言，依赖注入明确描述了 被注入对象依赖 IoC 容器配置依赖对象。 依赖注入的主要目的是为了解耦，体现了一种“组合”的理念。组合优于继承。 Java 有一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，Spring 就是通过反射来实现注入的。 依赖注入主要有三种方式： 构造方法注入构造方法注入，就是被注入对象可以通过在其构造方法中声明依赖对象的参数列表， 让外部(通常是IoC容器)知道它需要哪些依赖对象。IoC Service Provider 会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。 优点：对象在构造完成之后，即已进入就绪状态，可以马上使用。 缺点：当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反 射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且在 Java 中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多个构造方法，而参数数量的变动可能造成维护上的不便。 setter 方法注入当前对象只要为其依赖对象所对应的属性添加 setter 方法，就可以通过 setter 方法将相应的依赖对象设置到被注入对象中。 优点：因为方法可以命名，所以 setter 方法注入在描述性上要比构造方法注入好一些。另外，setter 方法可以被继承，允许设置默认值，而且有良好的IDE支持。 缺点：对象无法在构造完成后马上进入就绪状态。 接口注入接口注入比较死板和烦琐，如果需要注入依赖对象，被注入对象就必须声明和实现另外的接口。 接口注入是现在不甚提倡的一种方式。因为它强制被注入对象实现不必要的接口，带有侵入性。 参考 《Spring 揭秘》","categories":[{"name":"后端","slug":"back-end","permalink":"https://haohaio.github.io/categories/back-end/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://haohaio.github.io/tags/spring/"}]},{"title":"Spring Boot 注解之@SpringBootApplication","slug":"SpringBoot注解之-SpringBootApplication","date":"2018-12-15T13:12:34.000Z","updated":"2019-01-25T03:04:11.401Z","comments":true,"path":"back-end/spring-boot-logging-1544879554.html","link":"","permalink":"https://haohaio.github.io/back-end/spring-boot-logging-1544879554.html","excerpt":"","text":"我们经常可以在 Spring Boot 的引导类中见到如下代码： @SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 下面我们就来了解一下 @SpringBootApplication 这个注解。我们进入该注解的源码后就会发现，其内部主要是由 @ComponentScan、 @SpringBootConfiguration、 @EnableAutoConfiguration 这三个注解组成。接下来我们就来了解一下这三个注解 @SpringBootConfiguration查看源码发现 @SpringBootConfiguration 被 @Configuration 标注，声明当前类是一个配置类，等价于配置文件。再查看 @Configuration 源码发现，@Configuration 由 @Component 标注，表示将当前类添加到 spring 容器中，表示是一个组件。 Java 配置Java 配置是通过 @Configuration 和 @Bean 来实现的 @Configuration：声明当前类是一个配置类，相当于一个 Spring 配置的 xml 文件 @Bean：注解在方法上，声明当前方法返回的是一个 Bean Java 配置和注解配置的主要原则是：全局配置使用 Java 配置 (如数据库的相关配置、MVC 相关配置)，业务 Bean 的配置使用注解配置 (@Service、@Component、@Repository、@Controller) @EnableAutoConfiguration查看源码发现，@EnableAutoConfiguration 主要由 @AutoConfigurationPackage 和 @Import({AutoConfigurationImportSelector.class}) 这两个注解构成。 @AutoConfigurationPackage 的作用是将引导类所在包及其子包下面所有的组件添加到 spring 容器中。 @Import({AutoConfigurationImportSelector.class}) 的作用是就导入自动配置类，即从 classpath 中搜索所有 META-INF/spring.factories 配置文件，然后将其中 org.springframework.boot.autoconfigure.EnableAutoConfiguration key 对应的配置项加载到 spring 容器中。 @ComponentScan被 @ComponentScan 标注的类，会被 spring 容器进行管理。 Spring 里有四大注解：@Component、@Controller、@Service 和 @Repository。四个注解是等效的，可根据需要选用。 @ComponentScan 注解就是用来自动扫描被这些注解标识的类，最终生成 IoC 容器里的 Bean。","categories":[{"name":"后端","slug":"back-end","permalink":"https://haohaio.github.io/categories/back-end/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://haohaio.github.io/tags/spring/"}]},{"title":"Git 常用命令","slug":"Git常用命令","date":"2018-12-15T12:03:21.000Z","updated":"2019-01-14T02:30:45.501Z","comments":true,"path":"others/git-common-commands-1544875401.html","link":"","permalink":"https://haohaio.github.io/others/git-common-commands-1544875401.html","excerpt":"","text":"配置# 配置git的全局账号$ git config --global user.name \"username\"# 配置git的全局账号邮箱$ git config --global user.email \"email\"# 查看配置的结果$ git config --global -l 仓库# 新建本地仓库$ git init# 克隆远程仓库$ git clone url (gcl)# 查看所有远程仓库信息$ git remote -v (grv)# 添加远程仓库$ git remote add name url# 删除远程仓库$ git remote remove name 基本命令 git add # 提交所有Working Dir修改到Index$ git add .# 提交所有Working Dir中dir目录/file文件的修改到Index$ git add dir/file # \"git add .\" 和 \"git add -A\" 的区别?# stages new and modified, without deleted$ git add .# stages all$ git add -A (gaa) git commit # 提交所有Index修改到HEAD，并附上 commit message$ git commit -m (gcmsg)# 提交所有修改到HEAD(包含Working Dir和Index，但不包含new files)，并附上 commit message$ git commit -a -m (gcam)# 修订HEAD的修改$ git commit --amend git push # 提交本地仓库修改至Remote仓库的master分支$ git push origin master git reset # 从Index中恢复所有修改$ git reset# 恢复到HEAD的上一次提交$ git reset HEAD^(HEAD~1) git checkout # 撤销相应的文件修改$ git checkout file(dir)# 检出某一commit ID的修改$ git checkout d928a3 git clean # 删除untracked files$ git clean -f# 连 untracked 的目录也一起删掉$ git clean -fd# 查看哪些文件会被删除$ git clean -nfd git diff # 查看 Working Dir 与 Index 的区别$ git diff (gd)# 查看 Index 与 HEAD 的区别$ git diff –-cached (gdca)# 查看 Working Dir与 HEAD 的区别$ git diff HEAD git log # 显示 commit log$ git log# 显示代码差异$ git log -p# 概要显示$ git log --stat# 单行显示$ git log --pretty=oneline# 显示最近3条提交$ git log -3# 显示最近24h的提交$ git log --since=\"24 hours\"# 显示某file文件修改的记录$ git log file# 通过信息检索提交$ git log --grep=\"fixbug\"# 通过作者检索提交$ git log --author=\"yuanfang\" git reflog 会记录所有HEAD的历史，也就是说当你做 reset，checkout等操作的时候，这些操作会被记录在reflog中。 git fsck –lost-found 查看“丢失的”对象们，比如因reset而看不到的commit git show # 查看HEAD的所有代码改动$ git show# 查看某一commit ID的所有代码改动$ git show d928a3 git blame # 查看file文件每一行的最近一次修改的信息 $ git blame file# 查看file文件50行至60行的最近一次修改的信息$ git blame -L 50,60 file git stash # 将修改暂存入栈$ git stash# 恢复栈顶的修改$ git stash pop# 列出栈中所有修改$ git stash list# 列出栈中所有修改的代码详情$ git stash list -p# 恢复栈中指定修改$ git stash apply stash@&#123;1&#125;# 清空栈$ git stash clear# 删除栈中修改$ git stash drop stash@&#123;1&#125; 分支 git branch # 列出本地已经存在的分支$ git branch# 列出远程分支$ git branch -r# 列出本地分支和远程分支$ git branch -a# 创建新的分支new_branch$ git branch new_branch# 切换到分支new_branch$ git checkout new_branch# 删除分支new_branch$ git branch -d new_branch# 推送new_branch到Remote仓库$ git push origin new_branch# 删除Remote仓库new_branch$ git push origin :new_branch git merge &amp; git rebase &amp; git cherry-pick # 合并 master 到当前分支$ git merge master# 变基当前分支到 master$ git rebase master# 合并某个commit到当前分支$ git cherry-pick commit-id 标签# 列出本地已经存在的标签$ git tag# 创建新的标签new_tag$ git tag new_tag# 删除标签new_tag$ git tag -d new_tag # 推送new_tag到Remote仓库$ git push origin new_tag# 推送所有标签到Remote仓库$ git push origin --tags# 删除Remote仓库new_tag$ git push origin -d tag new_tag$ git push origin :refs/tags/new_tag# 获取Remote仓库所有的标签$ git fetch origin 补丁# 将修改写入到patch文件 .patch$ git diff &gt; .patch# 将.patch的修改恢复到当前git工程$ patch -p1 &lt; .patch .gitignore 配置规则 *.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt .gitignore文件发现却没有生效时（ .gitignore只能忽略那些原来没有被track的文件） $ git rm -r --cached .$ git add .$ git commit -m 'update .gitignore' 统计某人提交代码的次数 $ git log --pretty=oneline --author='username' | wc -l","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"Git","slug":"git","permalink":"https://haohaio.github.io/tags/git/"}]},{"title":"Canvas学习笔记一：初识Canvas","slug":"初识Canvas","date":"2018-12-13T11:51:53.000Z","updated":"2018-12-29T06:23:22.409Z","comments":true,"path":"front-end/canvas-1-1544701913.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-1-1544701913.html","excerpt":"","text":"简介canvas 元素可以说是 HTML5 元素中功能最强大的一个。我们可以通过 canvas 元素来绘制图像，不过 canvas 本身并没有绘制能力，必须通过js脚本来完成实际的绘制任务。canvas的能力主要是通过 canvas 的 context 对象表现出来的，该对象提供了用于在画布上绘图的方法和属性。 可以先看一个简单的 demo Hello Canvas，来简单了解一下canvas。 context 对象的获取var canvas = getElementById('canvas');// '2d' 中的 'd' 必须小写var context = canvas.getContext('2d'); canvas 的 “后备内容” (fallback content) IE8 以及更早的版本不支持 canvas 元素。 当浏览器不支持 canvas 元素时，canvas 元素内部部分所含的文本就会显示出来，这种文本叫做“后备内容” (fallback content)。 &lt;canvas&gt; Canvas not supported&lt;/canvas&gt; 另外我们可以通过简单的 js 代码来检查浏览器对 canvas 的支持性： var canvas = document.getElementById('canvas');if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); // drawing code here&#125; else &#123; // canvas-unsupported code here&#125; canvas 的尺寸默认的canvas元素大小是 300 * 150 个像素。 我们可以通过指定 width 和 height 属性值来修改 canvas 元素的大小。 &lt;canvas id=\"canvas\" width=\"600\" height=\"300\"&gt; 在设置 canvas 的宽度和高度时，不能使用 px 后缀。虽说支持 canvas 的浏览器普遍都允许使用 px 后缀，但是这是不被 canvas 规范所接受的。根据规范，这些属性的取值，只能是非负整数。 canvas 元素的大小和绘图表面的大小我们还可以通过 CSS 属性来改变 canvas 元素的大小。 #canvas &#123; width: 600px; height: 300px;&#125; 不过通过 CSS 设置 canvas 元素的大小，与通过 width、height 属性值设定，效果并不一样。 其根本原因是因为 canvas 元素实际上有两套尺寸。一个是元素本身的大小，还有一个是元素绘图表面（drawing surface）的大小。 当设置元素的 width 和 height 属性时，实际上是同时修改了元素本身的大小和元素绘图表面的大小。然而，通过 CSS 来设定 canvas 元素的大小时，只会改变元素本身的大小，而不会影响到绘图表面。当 canvas 元素的大小不符合起绘图表面的大小时，浏览器就会对绘图表面进行缩放，使其符合元素的大小。具体效果如如下面两幅图所示： 通过设置元素的 width 和 height 属性修改 canvas 元素大小的效果 通过 CSS 来设定 canvas 元素的大小的效果 （浏览器自动缩放） 所以一般情况下我们都是通过 width 与 height 属性而非 CSS 来修改 canvas 元素的大小。 canvas 元素的 APIcanvas 元素只提供了2个属性与3个方法。 canvas元素的属性 属性 类型 默认值 width 非负整数 300 height 非负整数 150 canvas元素的方法 方法 描述 getContext() 返回与该 canvas 元素相关的绘图环境对象。 toDataURL(type, encoderOptions) 返回一个数据地址（data URL），可将其设定为 img 元素的 src 属性值。第一个参数指定了图像的类型，例如 image/jpeg 或 image/png，默认为 image/png。第二个参数在指定图片格式为 image/jpeg 或 image/webp的情况下, 可设定为 0 ~ 1.0 之间的 double 值，表示 JPEG 图像的显示质量，如果超出取值范围，将会使用默认值 0.92。 toBlob(callback, type, encoderOptions) 创建一个用于表示次canvas 元素图像文件的 Blob。第一个参数是一个回调函数，并传入一个 blob 对象作为参数，第二个参数为图像类型，最后一个参数为 JPEG 图像的显示质量","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Web动画之animation","slug":"Web动画之animation","date":"2018-12-12T01:40:21.000Z","updated":"2018-12-17T07:35:47.551Z","comments":true,"path":"front-end/web-animation-animation-1544578821.html","link":"","permalink":"https://haohaio.github.io/front-end/web-animation-animation-1544578821.html","excerpt":"","text":"在 Web动画之transition 中我们可以了解到 transition 可以把一系列属性从一个状态变到另一个状态。CSS动画还提供了一种创建动画的方式，而且功能更加丰富。animation 能把一系列属性从一个状态变到另一个状态，再变到第三个状态，然后一直这么变下去。此外，还能重播动画，鼠标移到动画上时停止动画，甚至在动画结束时还能倒播动画。接下来我们就来了解一下 animation。 animation 比 transition 复杂一些，不过有个额外的好处：无需触发就能开始动画。 Animation 简介 与 transition 一样，IE9 及之前的版本也不支持 animation。 创建 animation 的过程主要分成以下两步： 定义动画即设置 keyframe (关键帧, 指展示画面的一帧)，列出要变化的CSS属性。基本结构如下： @keyframes animationName &#123; from &#123; /* 在这里列出CSS属性 */ &#125; to &#123; /* 在这里列出CSS属性 */ &#125;&#125; keyframes 不是CSS属性，而是@规则。此外，CSS还有几个@规则：在样式表中加载另外一个样式表的 @import 语句；为不同媒介类型定义样式的 @media。 首先在 @keyframes 后面定义一个名称，即动画的名称 (e.g. fadeIn、fadeOut)。 然后至少添加两个关键帧。在上面的示例中，关键字 from 用于创建起始关键帧，关键字 to 用于创建结束关键帧。在每个关键帧中可以添加一个或多个CSS属性，与定义样式一样。例如： fadeIn 不仅只能定义两个关键帧，还可以用百分比值定义多个关键帧。百分比表示在整个动画过程的什么位置发生变化。 例如：growAndGlow 百分比值的用法还有个特别的技巧：使用不同的百分比值定义相同的CSS属性。首先，当动画播放到摸一会时刻时暂停，然后再继续 (e.g. glow)。还可以用来不同时间段使用相同的CSS属性(e.g. glow) 可以把关键字 form 换成 0%，把关键字 to 换成 100%。 应用动画定义好动画后，若想播放动画，还需将动画应用到页面的元素上。 直接将动画加到动画的样式中，则动画在页面加载时就会播放(上面的例子都是如此)。 此外，可以把动画添加到某个伪类中 (e.g. :hover、:active、:target或:focus)，还可以把动画添加到类样式中，在需要的时候使用js动态应用那个类样式。 CSS提供了几个 animation 相关的属性，用于控制如何以及何时播放动画。 有些属性与 transition 基本相同，这里不做过多解释 animation-name 以CSS关键字做动画名称时，放在引号里能避免冲突 可以对应多个动画的名称，来让一个元素应用多个动画 animation-duration animation-timing-function 可以为每个关键帧设置不同的时序函数 animation-dealy animation-iteration-count (动画运行次数)(e.g. animation-iteration-count: 10;) 设为关键字 infinite 时，可无限次运行动画 animation-direction 当动画多次执行时，如有需要，可设为 alternate 关键字，动画会在奇数时正向播放，偶数时反向播放。 animation-fill-mode 可设为 forwords 关键字，当动画结束时让元素显示成动画结束后的样子。 animation属性的简写形式 名字和持续时间是必写的。 多个动画时，可用逗号分开。 暂停动画若有需要可使用伪类或js设置 animation-play-state (running|paused) 属性为 paused 来暂停动画。 推荐推荐一个CSS animation库 animate.css，这个库封装了很多动画，拿来即用，非常方便。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Web动画之transition","slug":"Web动画之transition","date":"2018-12-09T06:28:26.000Z","updated":"2018-12-17T07:35:45.995Z","comments":true,"path":"front-end/web-animation-transition-1544336906.html","link":"","permalink":"https://haohaio.github.io/front-end/web-animation-transition-1544336906.html","excerpt":"","text":"目前Web动画主要有两大实现途径： CSS3动画。这类动画是当前页面动画的主力军，主要通过 transition 和 animation 两种方式来实现。 transition (过渡) 一种简单的动画，在一定时间内从一组CSS\b属性变成另一组属性。 animation 是关键帧动画，可以预先为动画设置多个节点，在每个节点中含有不同的状态属性，通过使用 animation 我们可以得到更为复杂的动画效果。 JavaScript动画。这类动画是通过JavaScript来动态的控制并刷新元素的各个属性值，以形成动画效果。 除以上两者外，我们也可以使用SVG 或 canvas等来制作动画。 一般来说，大部分简单的动画都可以使用 transition 实现。JavaScript动画则往往用于更加复杂，或是需要结合各类用户交互操作的动画效果。在运行效率方面，像jQuery这种JavaScript类库的动画效果要低于CSS3动画。而在兼容性方面，CSS3动画的兼容性要差于jQuery等类库动画，前者并不支持IE9之前的浏览器。今天就先了解一下 transition 动画。 Transition简介一种简单的动画，在一定时间内从一组CSS\b属性变成另一组属性。 IE只有10和以后的版本才支持transition 为了实现过渡效果，要满足以下几个条件： 两个样式 (过渡前的样式和过渡\b后的样式) transition\b属性 (\b\b添加到初始样式中) 触发器 (指促使元素在两个在两个元素之间变化的操作。在CSS中可以使用伪类触发动画 (e.g. :hover、:active、:target或:focus)，还可以使用js触发 (增删类或者修改属性)) transition 的四个属性 transition-property (指定需要变化的属性，\b可用关键字all表示所有属性) transition-property: color, background-color;transition-property: all; transition-duration (动画持续时间) transition-duration: .5s;transition-duration: 500ms; transition-timing-function (过渡的时序，即持续过程的速率) linear (中间快，两头慢) ease (\b开始时慢，中间加速，\b末尾又降速)default ease-in \b(开始时慢，之后快) ease-out \b(开始时快，结束时候慢) ease-in-out (两头慢) 可通过演示具体比较一下\b\b各个速率的区别 演示地址 transition-delay (动画\b延时时间) transition属性的简写形式 要变化的属性和动画的持续时间是必写的。默认情况下，时序函数是ease，而且没有延迟。 多个要变化的属性时，可用逗号分开。 transition: all 1s;transition: background-color 1s, color .5s, border-color .5s 1s; 附上一个综合版的Demo transition demo 让动画更流畅以动画形式改变多个属性会增加Web浏览器的负担。一次有太多动画可能导致浏览器假死，甚至是崩溃。尤其是移动设备和平板电脑，因为这些设备的CPU比桌面电脑和笔记本电脑慢很多。 不过，有4种变化导致浏览器使用太多CPU：opacity，以及transform属性的translate、scale和rotate函数。这四个属性处理起来比其它CSS属性省事，所以它们的动画效果更流畅。 此外，还可以强制让电脑的GPU (Graphic Processing Unit, 图形处理器) 渲染动画。GPU的运算速度特别快，与电脑的CPU相比，执行特定类型的计算速度快得多。我们可以在样式中添加3D变形属性，以此“骗过”浏览器，让它使用GPU处理样式变化。但是因为GPU的处理能力有限，如果把太多视觉效果交给它处理，可能会拖慢浏览器，导致假死。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]}]}