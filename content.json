{"meta":{"title":"灏絯喔","subtitle":"一个人的小角落","description":"好记性不如烂笔头","author":"haohaio","url":"https://haohaio.github.io"},"pages":[{"title":"为何建站 && 为何写作","date":"2018-12-12T04:12:12.000Z","updated":"2018-12-15T11:56:25.307Z","comments":false,"path":"about/index.html","permalink":"https://haohaio.github.io/about/index.html","excerpt":"","text":"为何建站这个网站主要是为了在学习的过程中记一下笔记，深化一下记忆。当然大家浏览本网站时，我相信大家也可以学到一点东西。 为何写作目前在我看来，写作还是个比较花时间的活儿。但是在写作的过程中，对自己各方面的提升还是蛮大的，所以我会尽量坚持下去。 作为内容站，持续输出高质量的内容是件不太容易的事情，本站的任何文章，你可任意转载，但请保留原文链接。"},{"title":"嘉宾推荐","date":"2018-12-12T04:12:12.000Z","updated":"2018-12-15T14:49:20.094Z","comments":false,"path":"links/index.html","permalink":"https://haohaio.github.io/links/index.html","excerpt":"","text":"以下摘录有趣、有意义、有影响力、有正能量的博客、资源 此处不做网址导航，因此不接受以SEO为目的的友链。排序不分那啥… JS大法系 阮一峰博客闲情写手腾讯AlloyTeam 苹果派 王巍（喵神）的博客Objc.ioSwifter 娱乐圈 VIMCodeTank 公众号 没有链接，请直接关注微信公众号：涔汐(zhangcenxi99)、小道消息、MacTalk等等"},{"title":"QA - 帮助中心","date":"2018-12-12T04:12:12.000Z","updated":"2018-12-15T11:59:51.436Z","comments":true,"path":"help/index.html","permalink":"https://haohaio.github.io/help/index.html","excerpt":"","text":"Q: 为什么博客有时候打开速度很慢，一直在加载呢？ A: 评论组件使用的Disqus等资源的服务器在墙外，你懂的…(不懂问搜狗)。不过不影响文章阅读。 暂时更新这些，需要什么本文底部留言…"},{"title":"标签云","date":"2017-02-04T07:37:12.000Z","updated":"2018-12-16T02:38:49.205Z","comments":true,"path":"tags/index.html","permalink":"https://haohaio.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[Java LeetCode]9. Palindrome Number","slug":"leetcode-palindrome-number","date":"2018-12-22T02:19:46.000Z","updated":"2018-12-22T02:52:20.637Z","comments":true,"path":"others/leetcode-palindrome-number-1545445186.html","link":"","permalink":"https://haohaio.github.io/others/leetcode-palindrome-number-1545445186.html","excerpt":"","text":"原题链接 Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121Output: true Example 2: Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? 解法一题意是判断一个有符号整型数是否是回文，即逆序过来的整数和原整数相同。则负数肯定不是，非 0 的 10 的倍数的数也不是。那就把数字进行反转进行比较就可得出结果。代码如下： class Solution &#123; public boolean isPalindrome(int x) &#123; if(x &lt; 0 || (x != 0 &amp;&amp; x % 10 == 0)) &#123; return false; &#125; int copyX = x; int revertedNumber = 0; while (copyX != 0) &#123; revertedNumber = revertedNumber * 10 + copyX % 10; copyX /= 10; &#125; return x == reverse; &#125;&#125; 解法2但其实我们不需要将数字完全反转进行比对，只需要将数字反转一半进行然后与前面一半的数字进行比对即可。代码如下： class Solution &#123; public boolean isPalindrome(int x) &#123; if(x &lt; 0 || (x != 0 &amp;&amp; x % 10 == 0)) &#123; return false; &#125; int revertedNumber = 0; while (x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; &#125; return x == revertedNumber || x == revertedNumber / 10; &#125;&#125;","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://haohaio.github.io/tags/Leetcode/"}]},{"title":"[Java LeetCode]7. Reverse Integer","slug":"leetcode-reverse-integer","date":"2018-12-21T15:08:32.000Z","updated":"2018-12-22T02:32:41.648Z","comments":true,"path":"others/leetcode-reverse-integer-1545404912.html","link":"","permalink":"https://haohaio.github.io/others/leetcode-reverse-integer-1545404912.html","excerpt":"","text":"原题链接 Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123Output: 321 Example 2: Input: -123Output: -321 Example 3: Input: 120Output: 21 Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 解法： 对数字进行反转的方法如下 int pop = x % 10;x /= 10;int rev = 0;rev = rev * 10 + pop; 在32位的机器上，Integer 的取值范围为 [-2^31, 2^31 -1], 即 [-2147483648, 2147483647]。所以最后反转的结果有可能会超出取值范围，需要进行特殊处理。 代码如下： class Solution &#123; public int reverse(int x) &#123; int rev = 0; while (x != 0) &#123; int pop = x % 10; x /= 10; // Integer.MAX_VALUE = 2147483647 if (rev &gt; Integer.MAX_VALUE / 10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) &#123; return 0; &#125;; // Integer.MIN_VALUE = -2147483648 if (rev &lt; Integer.MIN_VALUE / 10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) &#123; return 0; &#125;; rev = rev * 10 + pop; &#125; return rev; &#125;&#125;","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[Java LeetCode]1. Two Sum","slug":"leetcode-two-sum","date":"2018-12-21T13:24:11.000Z","updated":"2018-12-22T02:32:51.155Z","comments":true,"path":"others/leetcode-two-sum-1545398651.html","link":"","permalink":"https://haohaio.github.io/others/leetcode-two-sum-1545398651.html","excerpt":"","text":"原题链接 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 解法一：暴力解决，循环两次搞定。 public int[] twoSum(int[] nums, int target) &#123; int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; for (int j = i + 1; j &lt; len; j++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[] &#123; i, j &#125;; &#125; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; 解法二：利用 HashMap 作为存储，key 为当前元素值，value 为当前元素值的索引。遍历时判断 map 中是否存在 key 加上当前元素值可以等于目标值，如果存在，就证明 key 为第一个值，当前元素值为第二个值，各自取其索引即可。 维护数组中每个元素到其索引的映射的最佳方法是就是哈希表。 public int[] twoSum(int[] nums, int target) &#123; int len = nums.length; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; len; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[]&#123;map.get(complement), i&#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"CSS颜色值之HSL","slug":"CSS颜色值之HSL","date":"2018-12-20T10:01:17.000Z","updated":"2018-12-21T14:16:05.070Z","comments":true,"path":"front-end/css-color-hsl-1545300077.html","link":"","permalink":"https://haohaio.github.io/front-end/css-color-hsl-1545300077.html","excerpt":"","text":"CSS3 的 HSL 方法已经被现代浏览器广泛的支持，但在日常开发中还是很少使用，今天我们就来简单了解一下，示例代码如下： .test &#123; background-color: hsl(360, 50%, 50%);&#125; IE8 以及更早的版本不支持使用 HSL 设置颜色值。 RGB vs HSLCSS3 颜色规范中说到，之所以要增加对 HSL 格式的支持，是因为以 RGB 方式来指定颜色，主要有两个缺陷： 它是以硬件为导向的。这种表述颜色的形式，是基于“阴极射线管”的； 它不直观。 HSL 的 取值 H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360 S：Saturation(饱和度)。取值为：0.0% - 100.0% L：Lightness(亮度)。取值为：0.0% - 100.0% HSL颜色当然可以转换为 RGB颜色 或 HEX颜色。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"css","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Docker 入门","slug":"Docker入门","date":"2018-12-19T13:47:46.000Z","updated":"2018-12-20T11:07:53.324Z","comments":true,"path":"others/docker-introduction-1545227266.html","link":"","permalink":"https://haohaio.github.io/others/docker-introduction-1545227266.html","excerpt":"","text":"简介Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 Docker 系统有两个程序：Docker 服务端 和 Docker 客户端。 Docker 服务端是一个服务进程，管理着所有的容器。 Docker 客户端则扮演着 Docker 服务端的远程控制器，可以用来控制 Docker 的服务端进程。 大部分情况下，Docker 服务端和客户端运行在一台机器上。 # 查看 docker 版本$ docker version 虚拟机 VS Linux 容器Linux 容器与虚拟机享有相似的资源隔离和分配，但是两者还是有很大区别的。 虚拟机可以在一种操作系统里面运行另一种操作系统。看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。Linux 容器是 Linux 的一种虚拟化技术。它不是模拟一个完整的操作系统，而是对进程进行隔离。 由于 Linux 容器是进程级别的，相比虚拟机有很多优势： 启动快 (启动虚拟机就相当于启动操作系统) 资源占用少 (虚拟机会独占一部分内存和硬盘空间) 体积小 Docker Image An image is a lightweight, stand-alone, executable package that includes everything needed to run a piece of software, including the code, a runtime, libraries, environment variables, and config files. 只读模板，包含一个基本的操作系统。 # 搜索可用镜像$ docker search tutorial# 下载镜像（用户名/镜像名:标签名）默认标签为 lastest$ docker pull learn/tutorial# 利用该镜像创建一个容器，执行完成会进入 bash 界面，输入 exit 可退出$ docker run -it learn/tutorials bash# 查看所有镜像$ docker images# 删除镜像（需先删除使用镜像的容器，使用 -f 参数强制删除(不推荐)）$ docker rmi 镜像名/镜像id Docker container A container is a runtime instance of an image. 一个轻量级的沙箱，容器是从镜像创建的，应用的运行实例。可以启动、开始、停止和删除，容器彼此间相互隔离。 # 创建容器# -i：让容器的标准输入保持打开; -t：让docker分配一个伪终端(pseudo-tty)，并绑定到容器的标准输入上。即允许用户交互$ docker create -it --name ubuntu-demo ubuntu:16.04# 启动容器$ docker start 容器名/容器id# 查看正在运行的容器列表$ docker ps# 查看所有容器列表$ docker ps -a# 查看刚刚操作的容器id$ docker ps -l# 新建并启动容器 (docker run = docker create + docker start)(-d：后台运行)$ docker run -it ubuntu:16.04 /bin/bash# run 命令后可跟在镜像中运行的命令# 使用 Ubuntu 的 apt-get 命令来安装 ping 程序# 在执行 apt-get 命令的时候，要带上 -y 参数。如果不指定 -y 参数的话，apt-get 命令会进入交互模式，需要用户输入命令来进行确认，但在 Docker 环境中是无法响应这种交互的。$ docker run learn/tutorial apt-get install -y ping# 登录容器$ docker exec -it 容器名/容器id /bin/bash# 停止容器$ docker stop 容器名/容器id# 停止所有容器$ docker stop $(docker ps -a -q)# 删除容器$ docker rm 容器id（需先停止容器或者使用 -f）# 删除所有容器$ docker rm $(docker ps -a -q) Docker 数据管理# copy 本地文件到容器内$ docker cp ./index.html nginx-demo:/usr/share/nginx/html# Volume# 将本地的 ~/docker/nginx-demo 目录挂载到容器内部的 /usr/share/nginx/html$ docker run --name nginx-demo -v ~/docker/nginx-demo:/usr/share/nginx/html -d nginx Docker 端口映射在启动容器的时候，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。 # 将本地的 8001 端口映射到容器的 80 端口$ docker run --name nginx-demo -p 8001:80 -d nginx$ curl http://localhost:8001/# 查看容器端口映射情况$ docker port 容器名/容器id Docker 其它常用命令# 登录$ docker login -u 用户名 -p 密码# 发布镜像$ docker push 镜像名","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://haohaio.github.io/tags/docker/"}]},{"title":"Canvas学习笔记三：描边与填充","slug":"Canvas描边与填充","date":"2018-12-17T09:46:54.000Z","updated":"2018-12-22T07:54:41.853Z","comments":true,"path":"front-end/canvas-basic-drawing-1545040014.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-basic-drawing-1545040014.html","excerpt":"","text":"Canvas 的绘制操作主要分为两种：描边与填充。 文本的绘制anvas 的绘图环境提供了下面两个 API 来直接绘制文本： strokeText(string text, double x, double y) fillText(string text, double x, double y) 矩形的绘制Canvas 的绘图环境中仅有两个方法可以用来立即绘制图形 (其它都需要路径)，用于有关矩形的绘制： - strokeRect(double x, double y, double width, double height)- fillRect(double x, double y, double width, double height) 还有一个与矩形相关的 API，可用来清除矩形区域： - clearRect(double x, double y, double width, double height)\b 示例：Canvas Rect 描边与填充的样式 (strokeStyle &amp; fillStyle)颜色Canvas 默认使用的颜色为不透明的黑色。在绘制矩形的示例中通过 strokeStyle 属性修改的描边的颜色，通过 fillStyle 属性修改了填充的颜色。代码如下： // 设置描边颜色context.strokeStyle = 'red';// 设置填充颜色context.fillStyle = 'rgba(0, 0, 255, .5)'; 可看到左边矩形的边框遮盖了文本，这是因为边框用的是不透明色。 strokeStyle 与 fillStyle 的属性值可以是任意有效的 CSS 颜色字符串。可以用 RGB、RGBA、HSL、HSLA 以及十六进制 RGB 标注法来指定，还可以通过 ‘red’、‘yellow’ 这样的颜色名称来指定。 渐变色Canvas 元素支持线性 (linear) 渐变和放射 (radial) 渐变。 线性渐变我们可以通过 context 调用 createLinearGradient(double x1, double y1, double x2, double y2) 方法来创建线性渐变。需要向该方法传入两个点的 x、y 坐标，两点之间的连线就是 canvas 建立颜色渐变效果的依据。可通过该方法创建返回的 LinearGradient 实例调用 addColorStop(double stop, string color) 来向该渐变色添加颜色停止点。然后将该实例指定为 fillStyle 进行绘制。 示例：Canvas Linear Gradient 放射渐变我们可以通过 context 调用 createRadialGradient(double x1, double y1, double d1,double x2, double y2, double d2) 方法来创建放射渐变需要指定两个圆形 (x、y 指定圆心，d 指定半径)，它们表示某个圆锥的起止部位。该方法会返回一个 RadialGradient 实例。 示例：Canvas Radial Gradient 图案除了颜色和渐变色，Canvas 元素也允许使用图案来对图形和文本进行描边和填充。这里的图案可以是 image元素、canvas元素 或 video元素。 可以用 createPattern(pattern, string repetition) 来创建图案。第一个参数指定了图案所用的图像，第二个参数指定如何重复图案：repeat | repeat-x | repeat-y | no-repeat。 示例：Canvas Pattern","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Canvas学习笔记二：绘图环境","slug":"Canvas的绘图环境","date":"2018-12-17T07:33:17.000Z","updated":"2018-12-22T07:29:19.608Z","comments":true,"path":"front-end/canvas-context-1545031997.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-context-1545031997.html","excerpt":"","text":"canvas 元素仅仅是为了充当绘图环境对象的容器而存在的，该环境对象提供了全部的绘制功能。本篇文章我们只关注 2d 绘图环境。 2d 绘图环境Canvas 的 2d 绘图环境对象提供了功能强大的API，可以用来绘制图形与文本，显示并修改图像等等。本篇文章我们就对 canvas 绘图环境的属性和一些方法做一些简单的了解。 下表列出了绘图环境对象的所有属性： 属性 简介 canvas 指向绘图环境所属的canvas对象 fillstyle 指定该绘图环境在后续的图形填充操作中所使用的颜色，渐变色或方案 font 设定在调用绘图环境对象的 fillText() 或 strokeText() 方法时，所使用的字型 globalAlpha 全局透明度设定，取值范围 0~1.0 globalCompsiteOperation 将某个物体绘制在其他的物体之上时采用的绘制方式 lineCap 如何绘制线段的端点，可取的值：butt、round、square，默认值是 butt lineWidth 绘制线段的屏幕像素宽度。非负非无穷的 double 值，默认值是 1.0 lineJoin 在两条线段相交时如何绘制交点，可取的值：bevel, round, miter，默认值是 miter miterLimit 如何绘制 miter 形式的线段交点 shadowBlur 延伸的阴影效果，该值为高斯模糊方程式中的参数值，非负、非无穷的 double 值，默认值为 0 shadowColor 阴影的颜色值 shadowOffsetX 阴影效果的水平方向偏移量 shadowOffsetY 阴影效果的垂直方向偏移量 strokeStyle 对路径描边时所使用的绘制风格 textAlign fillText() 或 strokeText() 方法绘制的时候，所画文本的水平对齐方式 textBaseline fillText() 或 strokeText() 方法绘制的时候，所画文本的垂直对齐方式 此外，还有两个重要的方法，用来保存及恢复当前 canvas 绘图环境的所有属性： 方法 描述 save() 将当前 canvas 的状态推送到一个保存 canvas 状态的堆栈顶部 restore() 将 canvas 状态堆栈顶部的条目弹出。原来保存于栈顶的哪一组状态，在弹出之后，就被设置成 canvas 当前的状态了","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"使用 WePY 开发微信小程序","slug":"使用wepy开发微信小程序","date":"2018-12-17T02:10:45.000Z","updated":"2018-12-17T07:34:48.437Z","comments":true,"path":"front-end/hello-wepy-1545012645.html","link":"","permalink":"https://haohaio.github.io/front-end/hello-wepy-1545012645.html","excerpt":"","text":"项目搭建# 全局安装 WePY 命令行工具$ npm install wepy-cli -g# 使用 WePY 命令行工具新建一个 hello-wepy 项目$ wepy init standard hello-wepy# 安装依赖 &amp;&amp; 运行项目$ cd hello-wepy &amp;&amp; npm install &amp;&amp; npm run dev 开发工具微信开发者工具下载 微信开发者工具，安装成功后添加项目根目录为一个新项目即可。 根目录下有一个项目配置文件 - project.config.json，其中一些配置对应着微信开发者工具中的一些配置，需要注意一下 &#123; \"description\": \"project description\", \"setting\": &#123; \"urlCheck\": true, \"es6\": false, \"postcss\": false, \"minified\": false &#125;, \"compileType\": \"miniprogram\", \"appid\": \"touristappid\", \"projectname\": \"Project name\", \"miniprogramRoot\": \"./dist\"&#125; urlCheck：对应不检查安全域名选项，开启。 如果已配置好安全域名则建议关闭。 es6：对应关闭ES6转ES5选项，关闭。(未关闭会运行报错) postcss：对应关闭上传代码时样式自动补全选项，关闭。(某些情况下漏掉此项也会运行报错) minified：对应关闭代码压缩上传选项，关闭。(开启后，会导致真机 computed, props.sync 等等属性失效) 添加项目成功后，微信开发者工具展示如下： 使用 VS Code 进行开发推荐使用 VS Code 进行开发，可通过如下步骤来设置语法高亮： 在 Code 里先安装 Vue 的语法高亮插件 Vetur。 打开任意 .wpy 文件，点击右下角的选择语言模式，默认为纯文本；在弹出的窗口中选择 .wpy 的配置文件关联，在选择要与 .wpy 关联的语言模式中选择 Vue。 在 VS Code 编辑器设置中设置 settings.json，添加如下： &quot;files.associations&quot;: { &quot;*.wpy&quot;: &quot;vue&quot; }","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"微信小程序","slug":"mp-wechat","permalink":"https://haohaio.github.io/tags/mp-wechat/"}]},{"title":"Spring 之 IoC 简介","slug":"Spring之IoC简介","date":"2018-12-16T02:38:15.000Z","updated":"2018-12-18T02:21:36.836Z","comments":true,"path":"back-end/spring-ioc-1544927895.html","link":"","permalink":"https://haohaio.github.io/back-end/spring-ioc-1544927895.html","excerpt":"","text":"IoC (Inversion of Control)，中文通常翻译为“控制反转”。 好莱坞原则 “Don’t call us, we will call you.” 恰如其分地表达了“反转”的意味，是用来形容 IoC 最多的一句话。 为什么需要 IoC ？一般情况下，如果我们依赖于某个类或服务，最简单而有效的方式就是直接在类的构造函数中新建相应的依赖类。即我们自己主动地去获取依赖的对象。但其实我们最终要做的只是想要调用依赖对象的某项服务而已。只要用到这个依赖对象的时候，它能够准备就绪，我们完全可以不管这个对象是自己找来的还是别人送过来的。不需要自己去折腾。 实际上，IoC 就是为了帮助我们避免之前的“大费周折”，而提供了更加轻松简洁的方式。 IoC 的反转，就反转在让你从原来的事必躬亲，转变为现在的享受服务。简单点儿说，IoC 的理念就是，让别人为你服务! 通常情况下，被注入对象会直接依赖于被依赖对象。但是，在IoC的场景中，二者之间通过 IoC Service Provider 来打交道，所有的被注入对象和依赖对象现在由IoC Service Provider统一管理。 被注入对象需要什么，直接跟 IoC Service Provider 招呼一声，后者就会把相应的被依赖对象注入到被注入对象中，从而达到 IoC Service Provider 为被注入对象服务的目的。 IoC Service Provider 在这里就是通常的 IoC 容器所充当的角色。 从被注入对象的角度看，与之前直接寻求依赖对象相比，依赖对象的取得方式发生了反转，控制也从被注入对象转到了 IoC Service Provider 那里。 依赖注入 (Dependency Injection)IoC 和 依赖注入 其实是同一个概念的不同角度描述。IoC 是通过依赖注入实现的。相对 IoC 而言，依赖注入明确描述了 被注入对象依赖 IoC 容器配置依赖对象。 依赖注入的主要目的是为了解耦，体现了一种“组合”的理念。组合优于继承。 Java 有一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，Spring 就是通过反射来实现注入的。 依赖注入主要有三种方式： 构造方法注入构造方法注入，就是被注入对象可以通过在其构造方法中声明依赖对象的参数列表， 让外部(通常是IoC容器)知道它需要哪些依赖对象。IoC Service Provider 会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。 优点：对象在构造完成之后，即已进入就绪状态，可以马上使用。 缺点：当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反 射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且在 Java 中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多个构造方法，而参数数量的变动可能造成维护上的不便。 setter 方法注入当前对象只要为其依赖对象所对应的属性添加 setter 方法，就可以通过 setter 方法将相应的依赖对象设置到被注入对象中。 优点：因为方法可以命名，所以 setter 方法注入在描述性上要比构造方法注入好一些。另外，setter 方法可以被继承，允许设置默认值，而且有良好的IDE支持。 缺点：对象无法在构造完成后马上进入就绪状态。 接口注入接口注入比较死板和烦琐，如果需要注入依赖对象，被注入对象就必须声明和实现另外的接口。 接口注入是现在不甚提倡的一种方式。因为它强制被注入对象实现不必要的接口，带有侵入性。 参考 《Spring 揭秘》","categories":[{"name":"后端","slug":"back-end","permalink":"https://haohaio.github.io/categories/back-end/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://haohaio.github.io/tags/spring/"}]},{"title":"Spring Boot 注解之@SpringBootApplication","slug":"SpringBoot注解之-SpringBootApplication","date":"2018-12-15T13:12:34.000Z","updated":"2018-12-18T02:57:15.750Z","comments":true,"path":"back-end/-1544879554.html","link":"","permalink":"https://haohaio.github.io/back-end/-1544879554.html","excerpt":"","text":"我们经常可以在 Spring Boot 的启动类代码中见到如下代码： @SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 下面我们就来了解一下 @SpringBootApplication 这个注解。我们进入该注解的源码后就会发现，其内部主要是由 @ComponentScan、 @SpringBootConfiguration、 @EnableAutoConfiguration 这三个注解组合。接下来我们就来了解一下这三个注解 @ComponentScanSpring 里有四大注解：@Component、@Controller、@Service 和 @Repository。可用来定义一个 bean。 @ComponentScan 注解就是用来自动扫描被这些注解标识的类，最终生成 IoC 容器里的 Bean。 四个注解是等效的，可根据需要选用 @Component：组件，没有明确的角色 @Controller：在展现层使用 @Service：在业务逻辑层使用 @Repository：在数据访问层使用 注入 Bean 的注解 三个注解一般情况下是通用的 @Autowired：Spring 提供的注解 @Inject：JSR-330 提供的注解 @Resource：JSR-250 提供的注解 @SpringBootConfiguration这个注解的作用与 @Configuration 作用相同，都是用来声明当前类是一个配置类。可以通过 ＠Bean 注解生成 IoC 容器管理的 bean。 Java 配置Java 配置是通过 @Configuration 和 @Bean 来实现的 @Configuration：声明当前类是一个配置类，相当于一个 Spring 配置的 xml 文件 @Bean：注解在方法上，声明当前方法返回的是一个 Bean Java 配置和注解配置的主要原则是：全局配置使用 Java 配置 (如数据库的相关配置、MVC 相关配置)，业务 Bean 的配置使用注解配置 (@Service、@Component、@Repository、@Controller) @EnableAutoConfiguration@EnableAutoConfiguration 是 Spring Boot 实现自动化配置的核心注解，通过这个注解把 Spring 应用所需的 bean 注入容器中。 总结Spring Boot 是通过注解 @EnableAutoConfiguration 的方式，去查找，过滤，加载所需的 configuration，@ComponentScan 扫描我们自定义的 bean，@SpringBootConfiguration 使得被 @SpringBootApplication 注解的类声明为注解类。 @SpringBootApplication = @SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan","categories":[{"name":"后端","slug":"back-end","permalink":"https://haohaio.github.io/categories/back-end/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://haohaio.github.io/tags/spring/"}]},{"title":"Git 常用命令","slug":"Git常用命令","date":"2018-12-15T12:03:21.000Z","updated":"2018-12-17T07:37:50.616Z","comments":true,"path":"others/git-common-commands-1544875401.html","link":"","permalink":"https://haohaio.github.io/others/git-common-commands-1544875401.html","excerpt":"","text":"配置# 配置git的全局账号$ git config --global user.name \"username\"# 配置git的全局账号邮箱$ git config --global user.email \"email\"# 查看配置的结果$ git config --global -l 仓库# 新建本地仓库$ git init# 克隆远程仓库$ git clone url (gcl)# 查看所有远程仓库信息$ git remote -v# 添加远程仓库$ git remote add name url# 删除远程仓库$ git remote remove name 基本命令 git add # 提交所有Working Dir修改到Index$ git add .# 提交所有Working Dir中dir目录/file文件的修改到Index$ git add dir/file # \"git add .\" 和 \"git add -A\" 的区别?# stages new and modified, without deleted$ git add .# stages all$ git add -A git commit # 提交所有Index修改到HEAD，并附上 commit message$ git commit -m# 提交所有修改到HEAD(包含Working Dir和Index，但不包含new files)，并附上 commit message$ git commit -a -m (gcam)# 修订HEAD的修改$ git commit --amend git push # 提交本地仓库修改至Remote仓库的master分支$ git push origin master git reset # 从Index中恢复所有修改$ git reset# 恢复到HEAD的上一次提交$ git reset HEAD^(HEAD~1) git checkout # 撤销相应的文件修改$ git checkout file(dir)# 检出某一commit ID的修改$ git checkout d928a3 git clean # 删除untracked files$ git clean -f# 连 untracked 的目录也一起删掉$ git clean -fd# 查看哪些文件会被删除$ git clean -nfd git diff # 查看Working Dir与Index的区别$ git diff# 查看Index与HEAD的区别$ git diff –-cached# 查看Working Dir与HEAD的区别$ git diff HEAD git log # 显示 commit log$ git log# 显示代码差异$ git log -p# 概要显示$ git log --stat# 单行显示$ git log --pretty=oneline# 显示最近3条提交$ git log -3# 显示最近24h的提交$ git log --since=\"24 hours\"# 显示某file文件修改的记录$ git log file# 通过信息检索提交$ git log --grep=\"fixbug\"# 通过作者检索提交$ git log --author=\"yuanfang\" git reflog 会记录所有HEAD的历史，也就是说当你做 reset，checkout等操作的时候，这些操作会被记录在reflog中。 git fsck –lost-found 查看“丢失的”对象们，比如因reset而看不到的commit git show # 查看HEAD的所有代码改动$ git show# 查看某一commit ID的所有代码改动$ git show d928a3 git blame # 查看file文件每一行的最近一次修改的信息 $ git blame file# 查看file文件50行至60行的最近一次修改的信息$ git blame -L 50,60 file git stash # 将修改暂存入栈$ git stash# 恢复栈顶的修改$ git stash pop# 列出栈中所有修改$ git stash list# 列出栈中所有修改的代码详情$ git stash list -p# 恢复栈中指定修改$ git stash apply stash@&#123;1&#125;# 清空栈$ git stash clear# 删除栈中修改$ git stash drop stash@&#123;1&#125; 分支 git branch # 列出本地已经存在的分支$ git branch# 列出远程分支$ git branch -r# 列出本地分支和远程分支$ git branch -a# 创建新的分支new_branch$ git branch new_branch# 切换到分支new_branch$ git checkout new_branch# 删除分支new_branch$ git branch -d new_branch# 推送new_branch到Remote仓库$ git push origin new_branch# 删除Remote仓库new_branch$ git push origin :new_branch git merge &amp; git rebase &amp; git cherry-pick # 合并master到当前分支$ git merge master# 变基当前分支到master$ git rebase master# 合并某个commit到当前分支$ git cherry-pick commit-id 标签# 列出本地已经存在的标签$ git tag# 创建新的标签new_tag$ git tag new_tag# 删除标签new_tag$ git tag -d new_tag # 推送new_tag到Remote仓库$ git push origin new_tag# 推送所有标签到Remote仓库$ git push origin --tags# 删除Remote仓库new_tag$ git push origin -d tag new_tag$ git push origin :refs/tags/new_tag# 获取Remote仓库所有的标签$ git fetch origin 补丁# 将修改写入到patch文件 .patch$ git diff &gt; .patch# 将.patch的修改恢复到当前git工程$ patch -p1 &lt; .patch .gitignore 配置规则 *.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt .gitignore文件发现却没有生效时（ .gitignore只能忽略那些原来没有被track的文件） $ git rm -r --cached .$ git add .$ git commit -m 'update .gitignore' 统计某人提交代码的次数 $ git log --pretty=oneline --author='username' | wc -l","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"Git","slug":"git","permalink":"https://haohaio.github.io/tags/git/"}]},{"title":"Canvas学习笔记一：初识Canvas","slug":"初识Canvas","date":"2018-12-13T11:51:53.000Z","updated":"2018-12-17T07:35:57.320Z","comments":true,"path":"front-end/canvas-1-1544701913.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-1-1544701913.html","excerpt":"","text":"简介canvas 元素可以说是 HTML5 元素中功能最强大的一个。我们可以通过 canvas 元素来绘制图像，不过 canvas 本身并没有绘制能力，必须通过js脚本来完成实际的绘制任务。canvas的能力主要是通过 canvas 的 context 对象表现出来的，该对象提供了用于在画布上绘图的方法和属性。 可以先看一个简单的 demo Hello Canvas，来简单了解一下canvas。 context 对象的获取var canvas = getElementById('canvas');// '2d' 中的 'd' 必须小写var context = canvas.getContext('2d'); canvas 的 “后备内容” (fallback content) IE8 以及更早的版本不支持 canvas 元素。 当浏览器不支持 canvas 元素时，canvas 元素内部部分所含的文本就会显示出来，这种文本叫做“后备内容” (fallback content)。 &lt;canvas&gt; Canvas not supported&lt;/canvas&gt; 另外我们可以通过简单的 js 代码来检查浏览器对 canvas 的支持性： var canvas = document.getElementById('canvas');if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); // drawing code here&#125; else &#123; // canvas-unsupported code here&#125; canvas 的尺寸默认的canvas元素大小是 300 * 150 个像素。 我们可以通过指定 width 和 height 属性值来修改 canvas 元素的大小。 &lt;canvas id=\"canvas\" width=\"600\" height=\"300\"&gt; 在设置 canvas 的宽度和高度时，不能使用 px 后缀。虽说支持 canvas 的浏览器普遍都允许使用 px 后缀，但是这是不被 canvas 规范所接受的。根据规范，这些属性的取值，只能是非负整数。 canvas 元素的大小和绘图表面的大小我们还可以通过 CSS 属性来改变 canvas 元素的大小。 #canvas &#123; width: 600px; height: 300px;&#125; 不过通过 CSS 设置 canvas 元素的大小，与通过 width、height 属性值设定，效果并不一样。 其根本原因是因为 canvas 元素实际上有两套尺寸。一个是元素本身的大小，还有一个是元素绘图表面（drawing surface）的大小。 当设置元素的 width 和 height 属性时，实际上是同时修改了元素本身的大小和元素绘图表面的大小。然而，通过 CSS 来设定 canvas 元素的大小时，只会改变元素本身的大小，而不会影响到绘图表面。当 canvas 元素的大小不符合起绘图表面的大小时，浏览器就会对绘图表面进行缩放，使其符合元素的大小。具体效果如如下面两幅图所示： 通过设置元素的 width 和 height 属性修改 canvas 元素大小的效果 通过 CSS 来设定 canvas 元素的大小的效果 （浏览器自动缩放） 所以一般情况下我们都是通过 width 与 height 属性而非 CSS 来修改 canvas 元素的大小。 canvas 元素的 APIcanvas 元素只提供了2个属性与3个方法。 canvas元素的属性 属性 类型 默认值 width 非负整数 300 height 非负整数 150 canvas元素的方法 方法 描述 getContext() 返回与该 canvas 元素相关的绘图环境对象。 toDataURL(type, encoderOptions) 返回一个数据地址（data URL），可将其设定为 img 元素的 src 属性值。第一个参数指定了图像的类型，例如 image/jpeg 或 image/png，默认为 image/png。第二个参数在指定图片格式为 image/jpeg 或 image/webp的情况下, 可设定为 0 ~ 1.0 之间的 double 值，表示 JPEG 图像的显示质量，如果超出取值范围，将会使用默认值 0.92。 toBlob(callback, type, encoderOptions) 创建一个用于表示次canvas 元素图像文件的 Blob。第一个参数是一个回调函数，并传入一个 blob 对象作为参数，第二个参数为图像类型，最后一个参数为 JPEG 图像的显示质量","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Web动画之animation","slug":"Web动画之animation","date":"2018-12-12T01:40:21.000Z","updated":"2018-12-17T07:35:47.551Z","comments":true,"path":"front-end/web-animation-animation-1544578821.html","link":"","permalink":"https://haohaio.github.io/front-end/web-animation-animation-1544578821.html","excerpt":"","text":"在 Web动画之transition 中我们可以了解到 transition 可以把一系列属性从一个状态变到另一个状态。CSS动画还提供了一种创建动画的方式，而且功能更加丰富。animation 能把一系列属性从一个状态变到另一个状态，再变到第三个状态，然后一直这么变下去。此外，还能重播动画，鼠标移到动画上时停止动画，甚至在动画结束时还能倒播动画。接下来我们就来了解一下 animation。 animation 比 transition 复杂一些，不过有个额外的好处：无需触发就能开始动画。 Animation 简介 与 transition 一样，IE9 及之前的版本也不支持 animation。 创建 animation 的过程主要分成以下两步： 定义动画即设置 keyframe (关键帧, 指展示画面的一帧)，列出要变化的CSS属性。基本结构如下： @keyframes animationName &#123; from &#123; /* 在这里列出CSS属性 */ &#125; to &#123; /* 在这里列出CSS属性 */ &#125;&#125; keyframes 不是CSS属性，而是@规则。此外，CSS还有几个@规则：在样式表中加载另外一个样式表的 @import 语句；为不同媒介类型定义样式的 @media。 首先在 @keyframes 后面定义一个名称，即动画的名称 (e.g. fadeIn、fadeOut)。 然后至少添加两个关键帧。在上面的示例中，关键字 from 用于创建起始关键帧，关键字 to 用于创建结束关键帧。在每个关键帧中可以添加一个或多个CSS属性，与定义样式一样。例如： fadeIn 不仅只能定义两个关键帧，还可以用百分比值定义多个关键帧。百分比表示在整个动画过程的什么位置发生变化。 例如：growAndGlow 百分比值的用法还有个特别的技巧：使用不同的百分比值定义相同的CSS属性。首先，当动画播放到摸一会时刻时暂停，然后再继续 (e.g. glow)。还可以用来不同时间段使用相同的CSS属性(e.g. glow) 可以把关键字 form 换成 0%，把关键字 to 换成 100%。 应用动画定义好动画后，若想播放动画，还需将动画应用到页面的元素上。 直接将动画加到动画的样式中，则动画在页面加载时就会播放(上面的例子都是如此)。 此外，可以把动画添加到某个伪类中 (e.g. :hover、:active、:target或:focus)，还可以把动画添加到类样式中，在需要的时候使用js动态应用那个类样式。 CSS提供了几个 animation 相关的属性，用于控制如何以及何时播放动画。 有些属性与 transition 基本相同，这里不做过多解释 animation-name 以CSS关键字做动画名称时，放在引号里能避免冲突 可以对应多个动画的名称，来让一个元素应用多个动画 animation-duration animation-timing-function 可以为每个关键帧设置不同的时序函数 animation-dealy animation-iteration-count (动画运行次数)(e.g. animation-iteration-count: 10;) 设为关键字 infinite 时，可无限次运行动画 animation-direction 当动画多次执行时，如有需要，可设为 alternate 关键字，动画会在奇数时正向播放，偶数时反向播放。 animation-fill-mode 可设为 forwords 关键字，当动画结束时让元素显示成动画结束后的样子。 animation属性的简写形式 名字和持续时间是必写的。 多个动画时，可用逗号分开。 暂停动画若有需要可使用伪类或js设置 animation-play-state (running|paused) 属性为 paused 来暂停动画。 推荐推荐一个CSS animation库 animate.css，这个库封装了很多动画，拿来即用，非常方便。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Web动画之transition","slug":"Web动画之transition","date":"2018-12-09T06:28:26.000Z","updated":"2018-12-17T07:35:45.995Z","comments":true,"path":"front-end/web-animation-transition-1544336906.html","link":"","permalink":"https://haohaio.github.io/front-end/web-animation-transition-1544336906.html","excerpt":"","text":"目前Web动画主要有两大实现途径： CSS3动画。这类动画是当前页面动画的主力军，主要通过 transition 和 animation 两种方式来实现。 transition (过渡) 一种简单的动画，在一定时间内从一组CSS\b属性变成另一组属性。 animation 是关键帧动画，可以预先为动画设置多个节点，在每个节点中含有不同的状态属性，通过使用 animation 我们可以得到更为复杂的动画效果。 JavaScript动画。这类动画是通过JavaScript来动态的控制并刷新元素的各个属性值，以形成动画效果。 除以上两者外，我们也可以使用SVG 或 canvas等来制作动画。 一般来说，大部分简单的动画都可以使用 transition 实现。JavaScript动画则往往用于更加复杂，或是需要结合各类用户交互操作的动画效果。在运行效率方面，像jQuery这种JavaScript类库的动画效果要低于CSS3动画。而在兼容性方面，CSS3动画的兼容性要差于jQuery等类库动画，前者并不支持IE9之前的浏览器。今天就先了解一下 transition 动画。 Transition简介一种简单的动画，在一定时间内从一组CSS\b属性变成另一组属性。 IE只有10和以后的版本才支持transition 为了实现过渡效果，要满足以下几个条件： 两个样式 (过渡前的样式和过渡\b后的样式) transition\b属性 (\b\b添加到初始样式中) 触发器 (指促使元素在两个在两个元素之间变化的操作。在CSS中可以使用伪类触发动画 (e.g. :hover、:active、:target或:focus)，还可以使用js触发 (增删类或者修改属性)) transition 的四个属性 transition-property (指定需要变化的属性，\b可用关键字all表示所有属性) transition-property: color, background-color;transition-property: all; transition-duration (动画持续时间) transition-duration: .5s;transition-duration: 500ms; transition-timing-function (过渡的时序，即持续过程的速率) linear (中间快，两头慢) ease (\b开始时慢，中间加速，\b末尾又降速)default ease-in \b(开始时慢，之后快) ease-out \b(开始时快，结束时候慢) ease-in-out (两头慢) 可通过演示具体比较一下\b\b各个速率的区别 演示地址 transition-delay (动画\b延时时间) transition属性的简写形式 要变化的属性和动画的持续时间是必写的。默认情况下，时序函数是ease，而且没有延迟。 多个要变化的属性时，可用逗号分开。 transition: all 1s;transition: background-color 1s, color .5s, border-color .5s 1s; 附上一个综合版的Demo transition demo 让动画更流畅以动画形式改变多个属性会增加Web浏览器的负担。一次有太多动画可能导致浏览器假死，甚至是崩溃。尤其是移动设备和平板电脑，因为这些设备的CPU比桌面电脑和笔记本电脑慢很多。 不过，有4种变化导致浏览器使用太多CPU：opacity，以及transform属性的translate、scale和rotate函数。这四个属性处理起来比其它CSS属性省事，所以它们的动画效果更流畅。 此外，还可以强制让电脑的GPU (Graphic Processing Unit, 图形处理器) 渲染动画。GPU的运算速度特别快，与电脑的CPU相比，执行特定类型的计算速度快得多。我们可以在样式中添加3D变形属性，以此“骗过”浏览器，让它使用GPU处理样式变化。但是因为GPU的处理能力有限，如果把太多视觉效果交给它处理，可能会拖慢浏览器，导致假死。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]}]}