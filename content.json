{"meta":{"title":"灏絯喔","subtitle":"一个人的小角落","description":"好记性不如烂笔头","author":"haohaio","url":"https://haohaio.github.io"},"pages":[{"title":"为何建站 && 为何写作","date":"2018-12-12T04:12:12.000Z","updated":"2018-12-15T11:56:25.307Z","comments":false,"path":"about/index.html","permalink":"https://haohaio.github.io/about/index.html","excerpt":"","text":"为何建站这个网站主要是为了在学习的过程中记一下笔记，深化一下记忆。当然大家浏览本网站时，我相信大家也可以学到一点东西。 为何写作目前在我看来，写作还是个比较花时间的活儿。但是在写作的过程中，对自己各方面的提升还是蛮大的，所以我会尽量坚持下去。 作为内容站，持续输出高质量的内容是件不太容易的事情，本站的任何文章，你可任意转载，但请保留原文链接。"},{"title":"嘉宾推荐","date":"2018-12-12T04:12:12.000Z","updated":"2018-12-15T14:49:20.094Z","comments":false,"path":"links/index.html","permalink":"https://haohaio.github.io/links/index.html","excerpt":"","text":"以下摘录有趣、有意义、有影响力、有正能量的博客、资源 此处不做网址导航，因此不接受以SEO为目的的友链。排序不分那啥… JS大法系 阮一峰博客闲情写手腾讯AlloyTeam 苹果派 王巍（喵神）的博客Objc.ioSwifter 娱乐圈 VIMCodeTank 公众号 没有链接，请直接关注微信公众号：涔汐(zhangcenxi99)、小道消息、MacTalk等等"},{"title":"标签云","date":"2017-02-04T07:37:12.000Z","updated":"2018-12-16T02:38:49.205Z","comments":true,"path":"tags/index.html","permalink":"https://haohaio.github.io/tags/index.html","excerpt":"","text":""},{"title":"QA - 帮助中心","date":"2018-12-12T04:12:12.000Z","updated":"2018-12-15T11:59:51.436Z","comments":true,"path":"help/index.html","permalink":"https://haohaio.github.io/help/index.html","excerpt":"","text":"Q: 为什么博客有时候打开速度很慢，一直在加载呢？ A: 评论组件使用的Disqus等资源的服务器在墙外，你懂的…(不懂问搜狗)。不过不影响文章阅读。 暂时更新这些，需要什么本文底部留言…"}],"posts":[{"title":"浅谈移动端H5页面的适配方案","slug":"html5-layout","date":"2019-01-07T10:10:11.000Z","updated":"2019-01-09T05:53:13.379Z","comments":true,"path":"front-end/html5-layout-1546855811.html","link":"","permalink":"https://haohaio.github.io/front-end/html5-layout-1546855811.html","excerpt":"","text":"由于现在的移动设备屏幕尺寸众多，所以要做好适配真的是一个让人头痛的问题。今天就来了解一下如何解决这个问题。 在介绍方案之前，我们要首先要对 viewport 的 meta 标签有一个大概的了解，其主要用来告诉浏览器如何规范的渲染 Web 页面。我们经常可以在页面中看到这样的代码： &lt;!-- 将视觉视口的宽度设置为设备宽度。网页不缩放，不允许用户缩放。页面占满整个屏幕 (适配“刘海”屏)。--&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover\"/&gt; 方案一：浏览器自动缩放首先来介绍一种最简单粗暴的一种解决方案： 假如我们设计稿的宽度是 750px, 那么我们可以将 viewport 的 meta 标签设置为这个样子： &lt;!-- 将视觉视口的宽度设置为 750px --&gt;&lt;meta name=\"viewport\" content=\"width=750\"&gt; 然后写 CSS 样式关于尺寸的值时，所有的值都保持与设计稿的大小一致，这样我们就可以适配各个不同尺寸的设备啦~~ 不信的话，可以复制代码在浏览器里悄悄： &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=750\"&gt; &lt;title&gt;固定视觉视口宽度，浏览器自动缩放&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; &#125; div &#123; height: 80px; line-height: 80px; margin-bottom: 80px; background: #000; color: #fff; font-size: 48px; text-align: center; &#125; #first &#123; width: 400px; &#125; #second &#123; width: 600px; &#125; #third &#123; width: 750px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"first\"&gt;400px&lt;/div&gt; &lt;div id=\"second\"&gt;600px&lt;/div&gt; &lt;div id=\"third\"&gt;750px&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这种做法，就是将视觉视口设置成固定的宽度，让浏览器自动缩放进行适配。但这种做法有一个很明显的弊端，就是不支持媒体查询，当我们需要跟聚设备宽度做一些样式的定制时，这种方案就做不到了。其原因就是我们将视觉视口设置成了固定的宽度，媒体查询时获得的宽度始终都是 750px 了。。。 简单来说，当我们的页面没有那么精致的时候，这种方案就可以满足我们的要求了~~ 方案二：动态设置缩放比例此外，我们还可以将视觉视口的宽度设为 device-width，动态设置缩放比例来进行适配。但这种方案其实与方案一是一样的，还是不支持媒体查询。因为缩放也会影响视觉视口的尺寸。这种方案相对于方案一来说，兼容性可能会更好一点，但具体兼容性没有进行测试，不太清楚~~ 动态设置缩放比例的代码如下： var resizeEvt = 'onorientationchange' in window ? 'orientationchange' : 'resize';var recalc = function() &#123; var metaEl = document.querySelector('meta[name=\"viewport\"]'); var designWidth = 750; // 设计稿的宽度 var scale = document.documentElement.clientWidth / designWidth; // 视觉视口宽度与设计稿宽度的比例 if (!metaEl) &#123; metaEl = document.createElement('meta'); metaEl.setAttribute('name', 'viewport'); metaEl.setAttribute('content', 'width=device-width, initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no', 'viewport-fit=cover'); document.documentElement.firstElementChild.appendChild(metaEl); &#125; else &#123; metaEl.setAttribute('content', 'width=device-width, initial-scale=' + scale + ', minimum-scale=' + scale + ', maximum-scale=' + scale + ', user-scalable=no', 'viewport-fit=cover'); &#125;&#125;;if (document.addEventListener) &#123; // 监听屏幕旋转事件 window.addEventListener(resizeEvt, recalc, false); // 监听 dom 内容加载完毕事件 document.addEventListener('DOMContentLoaded', recalc, false);&#125; document.documentElement.clientWidth 还是始终都是 750px。 方案三：使用 rem 进行布局有时为了让页面更加精致，我们还是不能将视觉视口设置成固定的宽度。一般情况下，我们通过设置告诉浏览器使用它的理想视口，即将视觉视口的宽度设为设备的宽度，并不进行缩放：s 苹果引入了理想视口的概念，它是对设备来说最理想的布局视口尺寸。理想视口中的网页用户最理想的宽度，用户进入页面的时候不需要缩放。 &lt;!-- 解决各种浏览器兼容问题的 理想视口 设置 --&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; CSS3 引入了 rem，rem 是一种 CSS 单位。简单来讲 rem 就是相对于根元素 &lt;html&gt; 的 font-size 来计算尺寸大小。 /* 设置根元素 html 的 font-size 为 16px */html &#123; font-size: 16px;&#125;/* 相对于根元素字体大小，所以为 32px */p &#123; font-size: 2rem;&#125; 基于此，我们可以使用 rem 布局来解决移动端 H5 页面的适配问题。即把与元素尺寸有关的 CSS 属性都以 rem 作为单位，通过计算为不同设备的根元素设置不同的 fontSize，这样页面在不同设备下就能保持一致的网页布局。 动态设置根元素的 fontSize 大小的代码简单如下： var docEl = document.documentElement; // 获取根元素，即 &lt;html&gt; 元素var designWidth = 750; // 设计稿的宽度var baseFontSize = 100; // 写代码时所基于的根元素的 fontsize 大小。为了便于计算，设为 100var resizeEvt = 'onorientationchange' in window ? 'orientationchange' : 'resize';// 重新计算根元素的 fontsizevar recalc = function () &#123; var clientWidth = docEl.clientWidth; // 视觉视口宽度，即 viewport 的 meta 标签中 width 所设置的值 (device-width) * 缩放比例 if (clientWidth) &#123; docEl.style.fontSize = baseFontSize * (clientWidth / designWidth) + 'px'; &#125;&#125;;if (document.addEventListener) &#123; // 监听屏幕旋转事件 window.addEventListener(resizeEvt, recalc, false); // 监听 dom 内容加载完毕事件 document.addEventListener('DOMContentLoaded', recalc, false);&#125; 此外，我们还可以通过 CSS 预处理器来帮助我们将设计稿中的 px 转为 rem，比如在 sass 中封装一个方法： $base-font-size: 100;// 计算 px 转 rem@function px2rem($pxWidth) &#123; @return $pxWidth / $base-font-size * 1rem&#125;","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"HTML5","slug":"html5","permalink":"https://haohaio.github.io/tags/html5/"}]},{"title":"[Java LeetCode]27. Remove Element","slug":"leetcode-remove-element","date":"2019-01-03T15:23:03.000Z","updated":"2019-01-04T01:34:04.590Z","comments":true,"path":"leetcode/leetcode-remove-element-1546528983.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-remove-element-1546528983.html","excerpt":"","text":"原题链接 Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example 1: Given nums = [3,2,2,3], val = 3,Your function should return length = 2, with the first two elements of nums being 2.It doesn&apos;t matter what you leave beyond the returned length. Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2,Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.Note that the order of those five elements can be arbitrary.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy)int len = removeElement(nums, val);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解法class Solution &#123; public int removeElement(int[] nums, int val) &#123; int newLength = 0; int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; if (nums[i] != val) &#123; nums[newLength] = nums[i]; newLength++; &#125; &#125; return newLength; &#125;&#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"使用 Docker 搭建 MySQL 服务","slug":"docker-mysql","date":"2019-01-03T01:45:56.000Z","updated":"2019-01-03T07:27:25.582Z","comments":true,"path":"others/docker-mysql-1546479956.html","link":"","permalink":"https://haohaio.github.io/others/docker-mysql-1546479956.html","excerpt":"","text":"最近在学习 Spring Boot 的时候，需要搭建一个 mysql 的服务，我们可以通过 docker 非常方便地搭建一个 mysql 服务。只需一个命令： # 默认使用 mysql:@latest 镜像，若未安装会自动下载$ docker run --name mysql-dev -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql –-name：给新创建的容器命名，此处命名为 mysql-dev -e：配置信息，此处配置 mysql 的 root 用户的登陆密码 -p：端口映射，此处映射主机 3306 端口到容器 mysql-dev 的 3306 端口 -d：成功启动容器后输出容器的 ID mysql 的服务已经搭好了。 可以通过 docker 连接上 mysql 服务，进行其它一些操作 # 登录容器$ docker exec -it mysql-dev bash# 连接 mysql 服务 (-p后面没有空格。第一次连接时会提示在命令行界面上直接使用密码不安全)$ mysql -p123456 # 创建一个数据库 db_examplemysql&gt; create database db_example;# 创建用户mysql&gt; create user 'springuser'@'%' identified by 'ThePassword';# 给 springuser 用户 db_example 的所有权限mysql&gt; grant all on db_example.* to 'springuser'@'%'; Tips发现使用可视化工具 (笔者用的 Navicat) 连接 mysql 服务时，会报 Authentication plugin &#39;caching_sha2_password&#39; cannot be loaded 错误。是因为新版本的 mysql 加密方式改了, 而当前可视化工具还不支持。所以我们先通过修改密码将加密方式改为以前的加密方式： mysql&gt; ALTER USER 'root' IDENTIFIED WITH mysql_native_password BY '123456';","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://haohaio.github.io/tags/docker/"}]},{"title":"Canvas学习笔记六：绘制仪表盘","slug":"canvas-dashboard","date":"2019-01-02T02:02:05.000Z","updated":"2019-01-02T08:41:45.005Z","comments":true,"path":"front-end/canvas-dashboard-1546394525.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-dashboard-1546394525.html","excerpt":"","text":"基于之前所学的关于 Canvas 的知识，来完成一个综合实例，绘制一个刻度仪表盘。 一、绘制网格线function drawGrid(color, stepX, stepY) &#123; context.save(); context.strokeStyle = color; context.lineWidth = 0.5; for (var i = stepX + 0.5; i &lt; context.canvas.width; i += stepX) &#123; context.beginPath(); context.moveTo(i, 0); context.lineTo(i, context.canvas.height); context.stroke(); &#125; for (var i = stepY + 0.5; i &lt; context.canvas.height; i += stepY) &#123; context.beginPath(); context.moveTo(0, i); context.lineTo(context.canvas.width, i); context.stroke(); &#125;&#125;drawGrid('lightgray', 10, 10); 二、绘制仪表盘中心圆点function drawCentroid() &#123; context.beginPath(); context.save(); context.strokeStyle = 'rgba(0, 0, 0, .5)'; context.fillStyle = 'rgba(80, 190, 240, .6)'; context.arc(canvas.width / 2, canvas.height / 2, 10, 0, Math.PI * 2, false); context.stroke(); context.fill(); context.restore();&#125; 三、绘制仪表盘指针function drawCentroidGuidewire() &#123; // 计算得到刻度指示点坐标 var angle = -Math.PI / 4; var radius = 205; var endPoint = &#123; x: canvas.width / 2 + radius * Math.cos(angle), y: canvas.height / 2 + radius * Math.sin(angle) &#125;; context.save(); context.strokeStyle = 'goldenrod'; context.fillStyle = 'rgba(250, 250, 0, 0.6)'; // 绘制刻度指示点 context.beginPath(); context.strokeStyle = 'rgba(100, 140, 230, 0.9)'; context.arc(endPoint.x, endPoint.y, 5, 0, Math.PI * 2, false); context.fill(); context.stroke(); // 绘制中心原点与指示点连接线 context.beginPath(); context.moveTo(canvas.width / 2 , canvas.height / 2); context.lineTo(endPoint.x, endPoint.y); context.stroke(); context.restore();&#125; 四、绘制外层圆圈function drawRing() &#123; drawRingOuterCircle(); context.strokeStyle = 'rgba(0, 0, 0, .1)'; context.arc(canvas.width / 2, canvas.height / 2, 185, 0, Math.PI * 2, false); context.fillStyle = 'rgba(100, 140, 230, .1)'; context.fill(); context.stroke();&#125;function drawRingOuterCircle() &#123; context.shadowColor = 'rgba(0, 0, 0, .7)'; context.shadowOffsetX = 3; context.shadowOffsetY = 3; context.shadowBlur = 6; context.strokeStyle = 'rgba(100, 140, 230, .5)'; context.beginPath(); context.arc(canvas.width / 2, canvas.height / 2, 205, 0, Math.PI * 2, true); context.stroke();&#125; 五、绘制内层圆function drawTickInnerCircle() &#123; context.sava(); context.beginPath(); context.strokeStyle = 'rgba(0, 0, 0, .1)'; context.arc(canvas.width / 2, canvas.height / 2, 175, 0, Math.PI * 2, false); context.stroke(); context.restore();&#125; 六、绘制刻度线function drawTicks() &#123; context.save(); for (var angle = 0, cnt = 0; angle &lt; Math.PI * 2; angle += Math.PI / 64, cnt++) &#123; drawTick(angle, 185, cnt++); &#125; context.restore();&#125;function drawTick(angle, radius, cnt) &#123; context.beginPath(); var tickWidth = cnt % 4 === 0 ? 10 : 5; context.moveTo(canvas.width / 2 + Math.cos(angle) * (radius - tickWidth), canvas.height / 2 + Math.sin(angle) * (radius - tickWidth)); context.lineTo(canvas.width / 2 + Math.cos(angle) * (radius), canvas.height + Math.sin(angle) * (radius)); context.strokeStyle = 'rgba(100, 140, 230, 0.7)'; context.stroke();&#125; 七、绘制标注function drawAnnotations() &#123; context.save(); context.fillStyle = 'rgba(0, 0, 230, 0.9)'; context.font = '12px Helvetica'; for (var angle = 0; angle &lt; 2 * Math.PI; angle += Math.PI / 8) &#123; context.beginPath(); context.fillText((angle * 180 / Math.PI).toFixed(0), canvas.width / 2 + Math.cos(angle) * (185 - 10 * 2), canvas.height / 2 - Math.sin(angle) * (185 - 10 * 2)); &#125; context.restore();&#125;","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Canvas学习笔记五：线段","slug":"canvas-line","date":"2018-12-29T03:01:09.000Z","updated":"2019-01-02T01:48:58.813Z","comments":true,"path":"front-end/canvas-line-1546052469.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-line-1546052469.html","excerpt":"","text":"Canvas 绘图环境提供了两个可以用来创建线段的方法： moveTo(x, y)向当前路径增加一条子路径，该子路径只包含一个点，就是参数传入的点。 lineTo(x, y)若当前路径没有子路径，那么这个方法就与 moveTo() 方法一样。如果当前路径中存在子路径，那么该方法会将会将参数传入的点加入到子路径中。 绘制线段时还是需要创建完路径后，调用 stroke() 方法才能绘制。 线段与像素边界 如果在像素边界绘制一条 1 像素宽的线段，那么 Canvas 的绘图环境对象会试着将分别将半个像素画在边界中线的两边。然而，在一个整像素范围内，绘制半个像素宽的像素是不可能的，所以边界两个方向的半个像素都被扩展为一个像素。所以最后绘制的线段宽度为 2 个像素。 如果将线段绘制在一个像素的中间，那么刚好绘制的就是 1 像素宽的线段。 示例 线段端点的绘制我们可以是使用 Canvas 绘图环境的 lineCap 属性来控制线段端点的绘制。可取值为： butt：默认值，无特殊处理。 round：在端点处多画一个半圆，其半径等于线宽的一半。 square：在端点处多画一个矩形，长度与线宽一致，宽度等于线宽的一半。 线段连接点的绘制我们可以是使用 Canvas 绘图环境的 lineJoin 属性来控制线段连接点的绘制。可取的值：bevel, round, miter，默认值是 miter，具体如下图所示： 当取值为 miter 时，还可以指定一个 miterLimit 属性，它表示对斜接线的长度与二分之一线宽的比值做出限制处理。 斜接线指的是在两条线交汇处内角和外角之间的距离。 若比值超过了设置的限制值，浏览器就会以 bevel 的方式来绘制线段的连接点。默认值为 10.0。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"[Java LeetCode]26. Remove Duplicates From Sorted Array","slug":"leetcode-remove-duplicates-from-sorted-array","date":"2018-12-29T02:02:51.000Z","updated":"2019-01-03T14:58:13.989Z","comments":true,"path":"leetcode/leetcode-remove-duplicates-from-sorted-array-1546048971.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-remove-duplicates-from-sorted-array-1546048971.html","excerpt":"","text":"原题链接 Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解法用一个 temp 变量记录要返回的长度，遍历数组时，如果后面的元素和前面的元素不同，就让 temp 变量加 1，最后返回 temp 即可。 class Solution &#123; public int removeDuplicates(int[] nums) &#123; int len = nums.length; if (len &lt;= 1) &#123; return len; &#125;; int temp = 1; for (int i = 1; i &lt; len; i++) &#123; if (nums[i - 1] != nums[i]) &#123; nums[temp] = nums[i]; temp++; &#125; &#125; return temp; &#125;&#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[Java LeetCode]21. Merge Two Sorted Lists","slug":"leetcode-merge-two-sorted-lists","date":"2018-12-27T13:11:26.000Z","updated":"2019-01-03T14:58:06.478Z","comments":true,"path":"leetcode/leetcode-merge-two-sorted-lists-1545916286.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-merge-two-sorted-lists-1545916286.html","excerpt":"","text":"原题链接 Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解法首先要对 ListNode 有一定的了解： ListNode 存储了两个变量：val 和 next。val 是这个节点的值，next 是指向下一节点的指针，当 next 为空指针时，这个节点是链表的最后一个节点。 class ListNode &#123; int val; // 当前指针的值 ListNode next; // 下一个节点 ListNode(int x)&#123; val = x; next = null; &#125;&#125; 新链表指针每次指向值小的节点，依次比较下去，最后，当其中一个链表到达了末尾，我们只需要把新链表指针指向另一个没有到末尾的链表此时的指针即可。 class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); ListNode temp = head; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt; l2.val) &#123; temp.next = l1; l1 = l1.next; &#125; else &#123; temp.next = l2; l2 = l2.next; &#125; temp = temp.next; &#125; temp.next = l1 != null ? l1 : l2; return head.next; &#125;&#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[Java LeetCode]20. Vaild Parentheses","slug":"leetcode-vaild-parentheses","date":"2018-12-26T14:32:30.000Z","updated":"2019-01-03T14:59:00.264Z","comments":true,"path":"leetcode/leetcode-vaild-parentheses-1545834750.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-vaild-parentheses-1545834750.html","excerpt":"","text":"原题链接 Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: Input: &quot;()&quot;Output: true Example 2: Input: &quot;()[]&#123;&#125;&quot;Output: true Example 3: Input: &quot;(]&quot;Output: false Example 4: Input: &quot;([)]&quot;Output: false Example 5: Input: &quot;&#123;[]&#125;&quot;Output: true 解法一通过观察发现，在合法的情况下，当遇到第一个右括号时，其前面紧邻的一个括号必定是和其匹配的左括号。那么我们可以用栈来解决这个问题，当出现左括号的时候入栈，当遇到右括号时，判断栈顶的左括号是否和其匹配，匹配的话出栈，不匹配的话直接返回 false 即可。最终判断是否空栈即可。 class Solution &#123; public boolean isValid(String s) &#123; HashMap&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;(); map.put(')', '('); map.put(']', '['); map.put('&#125;', '&#123;'); Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (map.containsKey(c)) &#123; char topElement = stack.empty() ? '#' : stack.pop(); if (topElement != map.get(c)) &#123; return false; &#125; &#125; else &#123; stack.push(c); &#125; &#125; return stack.isEmpty(); &#125;&#125; 解法二用数字的 ++ 和 --模拟栈的操作使其操作更快。有个细节注意下 top = 1;，从而省去了之后判空的操作和 top - 1 导致数组越界的错误。 class Solution &#123; public boolean isValid(String s) &#123; // HashMap&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;(); // map.put(')', '('); // map.put(']', '['); // map.put('&#125;', '&#123;'); int top = 1; char[] stack = new char[s.length() + top]; for (char c : s.toCharArray()) &#123; // if (map.containsKey(c)) &#123; // if (stack[--top] != map.get(c)) &#123; // return false; // &#125; // &#125; else &#123; // stack[top++] = c; // &#125; if (c == '(' || c == '[' || c == '&#123;') &#123; stack[top++] = c; &#125; else if (c == ')' &amp;&amp; stack[--top] != '(') &#123; return false; &#125; else if (c == ']' &amp;&amp; stack[--top] != '[') &#123; return false; &#125; else if (c == '&#125;' &amp;&amp; stack[--top] != '&#123;') &#123; return false; &#125; &#125; return top == 1; &#125;&#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[Java LeetCode]14. Longest Common Prefix","slug":"leetcode-longest-common-prefix","date":"2018-12-26T01:23:16.000Z","updated":"2019-01-03T14:58:16.447Z","comments":true,"path":"leetcode/leetcode-longest-common-prefix-1545787396.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-longest-common-prefix-1545787396.html","excerpt":"","text":"原题链接 Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”. Example 1: Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Example 2: Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. 解法一暴力破解。 class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) &#123; return \"\"; &#125;; String prefix = strs[0]; int len = strs.length; for (int i = 1; i &lt; len; i++) &#123; // prefix 不是当前项的前缀时 while (strs[i].indexOf(prefix) != 0) &#123; prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) &#123; return \"\"; &#125; &#125; &#125; return prefix; &#125;&#125; 解法二相对于解法一，使用垂直扫描进行优化。并取字符串数组中最短字符串的长度，以减少嵌套遍历次数。 class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) &#123; return \"\"; &#125;; int minLen = Integer.MAX_VALUE; for (String str : strs) &#123; minLen = Math.min(minLen, str.length()); &#125; for (int i = 0; i &lt; minLen; i++)&#123; char c = strs[0].charAt(i); for (int j = 1; j &lt; strs.length; j ++) &#123; if (strs[j].charAt(i) != c) &#123; return strs[0].substring(0, i); &#125; &#125; &#125; return strs[0].substring(0, minLen); &#125;&#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[Java LeetCode]13. Roman to Integer","slug":"leetcode-roman-to-integer","date":"2018-12-24T01:40:46.000Z","updated":"2019-01-03T14:58:45.901Z","comments":true,"path":"leetcode/leetcode-roman-to-integer-1545615646.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-roman-to-integer-1545615646.html","excerpt":"","text":"原题链接 Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: &quot;III&quot;Output: 3 Example 2: Input: &quot;IV&quot;Output: 4 Example 3: Input: &quot;IX&quot;Output: 9 Example 4: Input: &quot;LVIII&quot;Output: 58Explanation: L = 50, V = 30 and III = 3. Example 5: Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 解法可以看到罗马数字的计数机制中，小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数。其它情况都是数字相加即可。那么我们可以利用 HashMap 来完成罗马数字的 7 个数字符号与整数的映射关系，然后对字符串逆向遍历，处理得到结果。代码如下： class Solution &#123; public int romanToInt(String s) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int len = s.length(); int sum = map.get(s.charAt(len - 1)); for (int i = len - 2; i &gt;= 0; i--) &#123; if (map.get(s.charAt(i)) &lt; map.get(s.charAt(i + 1))) &#123; sum -= map.get(s.charAt(i)); &#125; else &#123; sum += map.get(s.charAt(i)); &#125; &#125; return sum; &#125;&#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"Canvas学习笔记四：路径","slug":"canvas-path","date":"2018-12-22T09:05:30.000Z","updated":"2018-12-26T14:12:32.926Z","comments":true,"path":"front-end/canvas-path-1545469530.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-path-1545469530.html","excerpt":"","text":"除了绘制矩形的两个 API 外，Canvas 的绘图环境还提供了其它一些方法用于绘制更加复杂的图形。这些方法都是基于路径 (path) 的。 图形路径 (rect &amp; arc)我们可以先看一个使用 context 提供的 API 绘制简单图形路径 (矩形和圆弧) 的基本示例：Canvas Path 通过示例，我们可以看到绘制图形的基本步骤如下： context 调用 beginPath() 方法来开始一段新的路径。 context 使用 rect() 或 arc() 方法分别创建矩形及弧形路径。 rect() 方法创建的路径是封闭的。 arc() 方法创建的路径，是不封闭的。除非是个圆形路径。可调用 closePath() 方法封闭路径。 context 调用 stroke() 或 fill() 方法，对路径进行描边或填充。 其中对 arc() 方法进行一下详细介绍： /** * x: 圆的中心的 x 坐标 * y: 圆的中心的 y 坐标 * radii: 圆的半径 * startAngle: 起始角，以弧度计。 (弧的圆形的三点钟位置是 0 度) * endAngle: 结束角，以弧度计。 * counterclockwise: 规定应该逆时针还是顺时针绘图。false = 顺时针，true = 逆时针。默认值为 false。 */arc(x, y, radii, startAngle, endAngle, counterclockwise) rect() 方法绘制路径时，总是顺时针方向的。(我们可以自定义方法来支持逆时针方向绘制矩形路径) 子路径Canvas 之中只能有一条路径存在，Canvas 规范将其称为 “当前路径”（current path）。然而，这条路径可以包含许多子路径（subpath）。而子路径是由两个或更多的点组成的。 如果在当前路径中存在子路径的情况下调用 arc() 方法, 那么此方法就会从子路径的终点向圆弧的起点画一条线。 填充路径时的 “非零环绕规则” (nonzero winding rule)如果当前路径是循环的，或是包含多个相交的子路径，那么 Canvas 的绘图环境就需要判断，当 fill() 方法被调用时，应该如何进行填充。Canvas 是使用 “非零环绕规则” 来进行判断的： 对于路径中任意指定区域，从该区域内部画一条足够长的线段，使此线段的完全落在路径范围之外。 然后，将计数器初始化为 0，每当这个线段与路径上的直线或曲线相交时，就改变计数器的值，如果是与路径顺时针相交时，那么计数器就加 1， 如果是与路径逆时针相交时，那么计数器就减 1。 如果计数器最终值不是 0，那么此区域就在路径范围里面，在调用 fill() 方法时，浏览器就会对其进行填充。如果最终值是 0，那么此区域就不在路径范围内，浏览器就不会对其进行填充。 具体情况如图所示：","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"[Java LeetCode]9. Palindrome Number","slug":"leetcode-palindrome-number","date":"2018-12-22T02:19:46.000Z","updated":"2019-01-03T14:58:05.031Z","comments":true,"path":"leetcode/leetcode-palindrome-number-1545445186.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-palindrome-number-1545445186.html","excerpt":"","text":"原题链接 Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121Output: true Example 2: Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? 解法一题意是判断一个有符号整型数是否是回文，即逆序过来的整数和原整数相同。则负数肯定不是，非 0 的 10 的倍数的数也不是。那就把数字进行反转进行比较就可得出结果。代码如下： class Solution &#123; public boolean isPalindrome(int x) &#123; if(x &lt; 0 || (x != 0 &amp;&amp; x % 10 == 0)) &#123; return false; &#125; int copyX = x; int revertedNumber = 0; while (copyX != 0) &#123; revertedNumber = revertedNumber * 10 + copyX % 10; copyX /= 10; &#125; return x == reverse; &#125;&#125; 解法2但其实我们不需要将数字完全反转进行比对，只需要将数字反转一半进行然后与前面一半的数字进行比对即可。代码如下： class Solution &#123; public boolean isPalindrome(int x) &#123; if(x &lt; 0 || (x != 0 &amp;&amp; x % 10 == 0)) &#123; return false; &#125; int revertedNumber = 0; while (x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; &#125; return x == revertedNumber || x == revertedNumber / 10; &#125;&#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[Java LeetCode]7. Reverse Integer","slug":"leetcode-reverse-integer","date":"2018-12-21T15:08:32.000Z","updated":"2019-01-03T14:58:40.913Z","comments":true,"path":"leetcode/leetcode-reverse-integer-1545404912.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-reverse-integer-1545404912.html","excerpt":"","text":"原题链接 Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123Output: 321 Example 2: Input: -123Output: -321 Example 3: Input: 120Output: 21 Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 解法： 对数字进行反转的方法如下 int pop = x % 10;x /= 10;int rev = 0;rev = rev * 10 + pop; 在32位的机器上，Integer 的取值范围为 [-2^31, 2^31 -1], 即 [-2147483648, 2147483647]。所以最后反转的结果有可能会超出取值范围，需要进行特殊处理。 代码如下： class Solution &#123; public int reverse(int x) &#123; int rev = 0; while (x != 0) &#123; int pop = x % 10; x /= 10; // Integer.MAX_VALUE = 2147483647 if (rev &gt; Integer.MAX_VALUE / 10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) &#123; return 0; &#125;; // Integer.MIN_VALUE = -2147483648 if (rev &lt; Integer.MIN_VALUE / 10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) &#123; return 0; &#125;; rev = rev * 10 + pop; &#125; return rev; &#125;&#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"[Java LeetCode]1. Two Sum","slug":"leetcode-two-sum","date":"2018-12-21T13:24:11.000Z","updated":"2019-01-03T14:58:55.011Z","comments":true,"path":"leetcode/leetcode-two-sum-1545398651.html","link":"","permalink":"https://haohaio.github.io/leetcode/leetcode-two-sum-1545398651.html","excerpt":"","text":"原题链接 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 解法一：暴力解决，循环两次搞定。 public int[] twoSum(int[] nums, int target) &#123; int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; for (int j = i + 1; j &lt; len; j++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[] &#123; i, j &#125;; &#125; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; 解法二：利用 HashMap 作为存储，key 为当前元素值，value 为当前元素值的索引。遍历时判断 map 中是否存在 key 加上当前元素值可以等于目标值，如果存在，就证明 key 为第一个值，当前元素值为第二个值，各自取其索引即可。 维护数组中每个元素到其索引的映射的最佳方法是就是哈希表。 public int[] twoSum(int[] nums, int target) &#123; int len = nums.length; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; len; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[]&#123;map.get(complement), i&#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;","categories":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/categories/leetcode/"}],"tags":[{"name":"LeetCode","slug":"leetcode","permalink":"https://haohaio.github.io/tags/leetcode/"}]},{"title":"CSS颜色值之HSL","slug":"CSS颜色值之HSL","date":"2018-12-20T10:01:17.000Z","updated":"2018-12-22T09:23:32.851Z","comments":true,"path":"front-end/css-color-hsl-1545300077.html","link":"","permalink":"https://haohaio.github.io/front-end/css-color-hsl-1545300077.html","excerpt":"","text":"CSS3 的 HSL 方法已经被现代浏览器广泛的支持，但在日常开发中还是很少使用，今天我们就来简单了解一下，示例代码如下： .test &#123; background-color: hsl(360, 50%, 50%);&#125; IE8 以及更早的版本不支持使用 HSL 设置颜色值。 RGB vs HSLCSS3 颜色规范中说到，之所以要增加对 HSL 格式的支持，是因为以 RGB 方式来指定颜色，主要有两个缺陷： 它是以硬件为导向的。这种表述颜色的形式，是基于“阴极射线管”的； 它不直观。 HSL 的 取值 H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360 S：Saturation(饱和度)。取值为：0.0% - 100.0% L：Lightness(亮度)。取值为：0.0% - 100.0% HSL颜色当然可以转换为 RGB颜色 或 HEX颜色。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Docker 入门","slug":"Docker入门","date":"2018-12-19T13:47:46.000Z","updated":"2018-12-20T11:07:53.324Z","comments":true,"path":"others/docker-introduction-1545227266.html","link":"","permalink":"https://haohaio.github.io/others/docker-introduction-1545227266.html","excerpt":"","text":"简介Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 Docker 系统有两个程序：Docker 服务端 和 Docker 客户端。 Docker 服务端是一个服务进程，管理着所有的容器。 Docker 客户端则扮演着 Docker 服务端的远程控制器，可以用来控制 Docker 的服务端进程。 大部分情况下，Docker 服务端和客户端运行在一台机器上。 # 查看 docker 版本$ docker version 虚拟机 VS Linux 容器Linux 容器与虚拟机享有相似的资源隔离和分配，但是两者还是有很大区别的。 虚拟机可以在一种操作系统里面运行另一种操作系统。看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。Linux 容器是 Linux 的一种虚拟化技术。它不是模拟一个完整的操作系统，而是对进程进行隔离。 由于 Linux 容器是进程级别的，相比虚拟机有很多优势： 启动快 (启动虚拟机就相当于启动操作系统) 资源占用少 (虚拟机会独占一部分内存和硬盘空间) 体积小 Docker Image An image is a lightweight, stand-alone, executable package that includes everything needed to run a piece of software, including the code, a runtime, libraries, environment variables, and config files. 只读模板，包含一个基本的操作系统。 # 搜索可用镜像$ docker search tutorial# 下载镜像（用户名/镜像名:标签名）默认标签为 lastest$ docker pull learn/tutorial# 利用该镜像创建一个容器，执行完成会进入 bash 界面，输入 exit 可退出$ docker run -it learn/tutorials bash# 查看所有镜像$ docker images# 删除镜像（需先删除使用镜像的容器，使用 -f 参数强制删除(不推荐)）$ docker rmi 镜像名/镜像id Docker container A container is a runtime instance of an image. 一个轻量级的沙箱，容器是从镜像创建的，应用的运行实例。可以启动、开始、停止和删除，容器彼此间相互隔离。 # 创建容器# -i：让容器的标准输入保持打开; -t：让docker分配一个伪终端(pseudo-tty)，并绑定到容器的标准输入上。即允许用户交互$ docker create -it --name ubuntu-demo ubuntu:16.04# 启动容器$ docker start 容器名/容器id# 查看正在运行的容器列表$ docker ps# 查看所有容器列表$ docker ps -a# 查看刚刚操作的容器id$ docker ps -l# 新建并启动容器 (docker run = docker create + docker start)(-d：后台运行)$ docker run -it ubuntu:16.04 /bin/bash# run 命令后可跟在镜像中运行的命令# 使用 Ubuntu 的 apt-get 命令来安装 ping 程序# 在执行 apt-get 命令的时候，要带上 -y 参数。如果不指定 -y 参数的话，apt-get 命令会进入交互模式，需要用户输入命令来进行确认，但在 Docker 环境中是无法响应这种交互的。$ docker run learn/tutorial apt-get install -y ping# 登录容器$ docker exec -it 容器名/容器id /bin/bash# 停止容器$ docker stop 容器名/容器id# 停止所有容器$ docker stop $(docker ps -a -q)# 删除容器$ docker rm 容器id（需先停止容器或者使用 -f）# 删除所有容器$ docker rm $(docker ps -a -q) Docker 数据管理# copy 本地文件到容器内$ docker cp ./index.html nginx-demo:/usr/share/nginx/html# Volume# 将本地的 ~/docker/nginx-demo 目录挂载到容器内部的 /usr/share/nginx/html$ docker run --name nginx-demo -v ~/docker/nginx-demo:/usr/share/nginx/html -d nginx Docker 端口映射在启动容器的时候，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。 # 将本地的 8001 端口映射到容器的 80 端口$ docker run --name nginx-demo -p 8001:80 -d nginx$ curl http://localhost:8001/# 查看容器端口映射情况$ docker port 容器名/容器id Docker 其它常用命令# 登录$ docker login -u 用户名 -p 密码# 发布镜像$ docker push 镜像名","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://haohaio.github.io/tags/docker/"}]},{"title":"Canvas学习笔记三：描边与填充","slug":"Canvas描边与填充","date":"2018-12-17T09:46:54.000Z","updated":"2019-01-02T02:00:59.345Z","comments":true,"path":"front-end/canvas-basic-drawing-1545040014.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-basic-drawing-1545040014.html","excerpt":"","text":"Canvas 的绘制操作主要分为两种：描边与填充。 坐标系统在进行绘制之前，我们还要先需要了解一下 Canvas 的坐标系统。只有先通过坐标确定了位置，Canvas 绘图环境才知道在哪里进行绘制。 在默认情况下，坐标系统是以 canvas 的左上角为原点，X 坐标向右方增长，Y 坐标向下方延伸。 但Canvas 的坐标系统并不是固定的，我们还可以对坐标系统进行平移、旋转、缩放等操作。这里先不做详细介绍 文本的绘制Canvas 的绘图环境提供了下面两个 API 来直接绘制文本： strokeText(string text, double x, double y) fillText(string text, double x, double y) 矩形的绘制Canvas 的绘图环境中仅有两个方法可以用来立即绘制图形 (其它都需要路径)，用于有关矩形的绘制： - strokeRect(double x, double y, double width, double height)- fillRect(double x, double y, double width, double height) 还有一个与矩形相关的 API，可用来清除矩形区域： - clearRect(double x, double y, double width, double height)\b 示例：Canvas Rect 描边与填充的样式 (strokeStyle &amp; fillStyle)颜色Canvas 默认使用的颜色为不透明的黑色。在绘制矩形的示例中通过 strokeStyle 属性修改的描边的颜色，通过 fillStyle 属性修改了填充的颜色。代码如下： // 设置描边颜色context.strokeStyle = 'red';// 设置填充颜色context.fillStyle = 'rgba(0, 0, 255, .5)'; 可看到左边矩形的边框遮盖了文本，这是因为边框用的是不透明色。 strokeStyle 与 fillStyle 的属性值可以是任意有效的 CSS 颜色字符串。可以用 RGB、RGBA、HSL、HSLA 以及十六进制 RGB 标注法来指定，还可以通过 ‘red’、‘yellow’ 这样的颜色名称来指定。 渐变色Canvas 元素支持线性 (linear) 渐变和放射 (radial) 渐变。 线性渐变我们可以通过 context 调用 createLinearGradient(double x1, double y1, double x2, double y2) 方法来创建线性渐变。需要向该方法传入两个点的 x、y 坐标，两点之间的连线就是 canvas 建立颜色渐变效果的依据。可通过该方法创建返回的 LinearGradient 实例调用 addColorStop(double stop, string color) 来向该渐变色添加颜色停止点。然后将该实例指定为 fillStyle 进行绘制。 示例：Canvas Linear Gradient 放射渐变我们可以通过 context 调用 createRadialGradient(double x1, double y1, double d1,double x2, double y2, double d2) 方法来创建放射渐变需要指定两个圆形 (x、y 指定圆心，d 指定半径)，它们表示某个圆锥的起止部位。该方法会返回一个 RadialGradient 实例。 示例：Canvas Radial Gradient 图案除了颜色和渐变色，Canvas 元素也允许使用图案来对图形和文本进行描边和填充。这里的图案可以是 image元素、canvas元素 或 video元素。 可以用 createPattern(pattern, string repetition) 来创建图案。第一个参数指定了图案所用的图像，第二个参数指定如何重复图案：repeat | repeat-x | repeat-y | no-repeat。 示例：Canvas Pattern","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Canvas学习笔记二：绘图环境","slug":"Canvas的绘图环境","date":"2018-12-17T07:33:17.000Z","updated":"2018-12-22T07:29:19.608Z","comments":true,"path":"front-end/canvas-context-1545031997.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-context-1545031997.html","excerpt":"","text":"canvas 元素仅仅是为了充当绘图环境对象的容器而存在的，该环境对象提供了全部的绘制功能。本篇文章我们只关注 2d 绘图环境。 2d 绘图环境Canvas 的 2d 绘图环境对象提供了功能强大的API，可以用来绘制图形与文本，显示并修改图像等等。本篇文章我们就对 canvas 绘图环境的属性和一些方法做一些简单的了解。 下表列出了绘图环境对象的所有属性： 属性 简介 canvas 指向绘图环境所属的canvas对象 fillstyle 指定该绘图环境在后续的图形填充操作中所使用的颜色，渐变色或方案 font 设定在调用绘图环境对象的 fillText() 或 strokeText() 方法时，所使用的字型 globalAlpha 全局透明度设定，取值范围 0~1.0 globalCompsiteOperation 将某个物体绘制在其他的物体之上时采用的绘制方式 lineCap 如何绘制线段的端点，可取的值：butt、round、square，默认值是 butt lineWidth 绘制线段的屏幕像素宽度。非负非无穷的 double 值，默认值是 1.0 lineJoin 在两条线段相交时如何绘制交点，可取的值：bevel, round, miter，默认值是 miter miterLimit 如何绘制 miter 形式的线段交点 shadowBlur 延伸的阴影效果，该值为高斯模糊方程式中的参数值，非负、非无穷的 double 值，默认值为 0 shadowColor 阴影的颜色值 shadowOffsetX 阴影效果的水平方向偏移量 shadowOffsetY 阴影效果的垂直方向偏移量 strokeStyle 对路径描边时所使用的绘制风格 textAlign fillText() 或 strokeText() 方法绘制的时候，所画文本的水平对齐方式 textBaseline fillText() 或 strokeText() 方法绘制的时候，所画文本的垂直对齐方式 此外，还有两个重要的方法，用来保存及恢复当前 canvas 绘图环境的所有属性： 方法 描述 save() 将当前 canvas 的状态推送到一个保存 canvas 状态的堆栈顶部 restore() 将 canvas 状态堆栈顶部的条目弹出。原来保存于栈顶的哪一组状态，在弹出之后，就被设置成 canvas 当前的状态了","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"使用 WePY 开发微信小程序","slug":"使用wepy开发微信小程序","date":"2018-12-17T02:10:45.000Z","updated":"2018-12-17T07:34:48.437Z","comments":true,"path":"front-end/hello-wepy-1545012645.html","link":"","permalink":"https://haohaio.github.io/front-end/hello-wepy-1545012645.html","excerpt":"","text":"项目搭建# 全局安装 WePY 命令行工具$ npm install wepy-cli -g# 使用 WePY 命令行工具新建一个 hello-wepy 项目$ wepy init standard hello-wepy# 安装依赖 &amp;&amp; 运行项目$ cd hello-wepy &amp;&amp; npm install &amp;&amp; npm run dev 开发工具微信开发者工具下载 微信开发者工具，安装成功后添加项目根目录为一个新项目即可。 根目录下有一个项目配置文件 - project.config.json，其中一些配置对应着微信开发者工具中的一些配置，需要注意一下 &#123; \"description\": \"project description\", \"setting\": &#123; \"urlCheck\": true, \"es6\": false, \"postcss\": false, \"minified\": false &#125;, \"compileType\": \"miniprogram\", \"appid\": \"touristappid\", \"projectname\": \"Project name\", \"miniprogramRoot\": \"./dist\"&#125; urlCheck：对应不检查安全域名选项，开启。 如果已配置好安全域名则建议关闭。 es6：对应关闭ES6转ES5选项，关闭。(未关闭会运行报错) postcss：对应关闭上传代码时样式自动补全选项，关闭。(某些情况下漏掉此项也会运行报错) minified：对应关闭代码压缩上传选项，关闭。(开启后，会导致真机 computed, props.sync 等等属性失效) 添加项目成功后，微信开发者工具展示如下： 使用 VS Code 进行开发推荐使用 VS Code 进行开发，可通过如下步骤来设置语法高亮： 在 Code 里先安装 Vue 的语法高亮插件 Vetur。 打开任意 .wpy 文件，点击右下角的选择语言模式，默认为纯文本；在弹出的窗口中选择 .wpy 的配置文件关联，在选择要与 .wpy 关联的语言模式中选择 Vue。 在 VS Code 编辑器设置中设置 settings.json，添加如下： &quot;files.associations&quot;: { &quot;*.wpy&quot;: &quot;vue&quot; }","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"微信小程序","slug":"mp-wechat","permalink":"https://haohaio.github.io/tags/mp-wechat/"}]},{"title":"Spring 之 IoC 简介","slug":"Spring之IoC简介","date":"2018-12-16T02:38:15.000Z","updated":"2018-12-18T02:21:36.836Z","comments":true,"path":"back-end/spring-ioc-1544927895.html","link":"","permalink":"https://haohaio.github.io/back-end/spring-ioc-1544927895.html","excerpt":"","text":"IoC (Inversion of Control)，中文通常翻译为“控制反转”。 好莱坞原则 “Don’t call us, we will call you.” 恰如其分地表达了“反转”的意味，是用来形容 IoC 最多的一句话。 为什么需要 IoC ？一般情况下，如果我们依赖于某个类或服务，最简单而有效的方式就是直接在类的构造函数中新建相应的依赖类。即我们自己主动地去获取依赖的对象。但其实我们最终要做的只是想要调用依赖对象的某项服务而已。只要用到这个依赖对象的时候，它能够准备就绪，我们完全可以不管这个对象是自己找来的还是别人送过来的。不需要自己去折腾。 实际上，IoC 就是为了帮助我们避免之前的“大费周折”，而提供了更加轻松简洁的方式。 IoC 的反转，就反转在让你从原来的事必躬亲，转变为现在的享受服务。简单点儿说，IoC 的理念就是，让别人为你服务! 通常情况下，被注入对象会直接依赖于被依赖对象。但是，在IoC的场景中，二者之间通过 IoC Service Provider 来打交道，所有的被注入对象和依赖对象现在由IoC Service Provider统一管理。 被注入对象需要什么，直接跟 IoC Service Provider 招呼一声，后者就会把相应的被依赖对象注入到被注入对象中，从而达到 IoC Service Provider 为被注入对象服务的目的。 IoC Service Provider 在这里就是通常的 IoC 容器所充当的角色。 从被注入对象的角度看，与之前直接寻求依赖对象相比，依赖对象的取得方式发生了反转，控制也从被注入对象转到了 IoC Service Provider 那里。 依赖注入 (Dependency Injection)IoC 和 依赖注入 其实是同一个概念的不同角度描述。IoC 是通过依赖注入实现的。相对 IoC 而言，依赖注入明确描述了 被注入对象依赖 IoC 容器配置依赖对象。 依赖注入的主要目的是为了解耦，体现了一种“组合”的理念。组合优于继承。 Java 有一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，Spring 就是通过反射来实现注入的。 依赖注入主要有三种方式： 构造方法注入构造方法注入，就是被注入对象可以通过在其构造方法中声明依赖对象的参数列表， 让外部(通常是IoC容器)知道它需要哪些依赖对象。IoC Service Provider 会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。 优点：对象在构造完成之后，即已进入就绪状态，可以马上使用。 缺点：当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反 射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且在 Java 中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多个构造方法，而参数数量的变动可能造成维护上的不便。 setter 方法注入当前对象只要为其依赖对象所对应的属性添加 setter 方法，就可以通过 setter 方法将相应的依赖对象设置到被注入对象中。 优点：因为方法可以命名，所以 setter 方法注入在描述性上要比构造方法注入好一些。另外，setter 方法可以被继承，允许设置默认值，而且有良好的IDE支持。 缺点：对象无法在构造完成后马上进入就绪状态。 接口注入接口注入比较死板和烦琐，如果需要注入依赖对象，被注入对象就必须声明和实现另外的接口。 接口注入是现在不甚提倡的一种方式。因为它强制被注入对象实现不必要的接口，带有侵入性。 参考 《Spring 揭秘》","categories":[{"name":"后端","slug":"back-end","permalink":"https://haohaio.github.io/categories/back-end/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://haohaio.github.io/tags/spring/"}]},{"title":"Spring Boot 注解之@SpringBootApplication","slug":"SpringBoot注解之-SpringBootApplication","date":"2018-12-15T13:12:34.000Z","updated":"2018-12-18T02:57:15.750Z","comments":true,"path":"back-end/-1544879554.html","link":"","permalink":"https://haohaio.github.io/back-end/-1544879554.html","excerpt":"","text":"我们经常可以在 Spring Boot 的启动类代码中见到如下代码： @SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 下面我们就来了解一下 @SpringBootApplication 这个注解。我们进入该注解的源码后就会发现，其内部主要是由 @ComponentScan、 @SpringBootConfiguration、 @EnableAutoConfiguration 这三个注解组合。接下来我们就来了解一下这三个注解 @ComponentScanSpring 里有四大注解：@Component、@Controller、@Service 和 @Repository。可用来定义一个 bean。 @ComponentScan 注解就是用来自动扫描被这些注解标识的类，最终生成 IoC 容器里的 Bean。 四个注解是等效的，可根据需要选用 @Component：组件，没有明确的角色 @Controller：在展现层使用 @Service：在业务逻辑层使用 @Repository：在数据访问层使用 注入 Bean 的注解 三个注解一般情况下是通用的 @Autowired：Spring 提供的注解 @Inject：JSR-330 提供的注解 @Resource：JSR-250 提供的注解 @SpringBootConfiguration这个注解的作用与 @Configuration 作用相同，都是用来声明当前类是一个配置类。可以通过 ＠Bean 注解生成 IoC 容器管理的 bean。 Java 配置Java 配置是通过 @Configuration 和 @Bean 来实现的 @Configuration：声明当前类是一个配置类，相当于一个 Spring 配置的 xml 文件 @Bean：注解在方法上，声明当前方法返回的是一个 Bean Java 配置和注解配置的主要原则是：全局配置使用 Java 配置 (如数据库的相关配置、MVC 相关配置)，业务 Bean 的配置使用注解配置 (@Service、@Component、@Repository、@Controller) @EnableAutoConfiguration@EnableAutoConfiguration 是 Spring Boot 实现自动化配置的核心注解，通过这个注解把 Spring 应用所需的 bean 注入容器中。 总结Spring Boot 是通过注解 @EnableAutoConfiguration 的方式，去查找，过滤，加载所需的 configuration，@ComponentScan 扫描我们自定义的 bean，@SpringBootConfiguration 使得被 @SpringBootApplication 注解的类声明为注解类。 @SpringBootApplication = @SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan","categories":[{"name":"后端","slug":"back-end","permalink":"https://haohaio.github.io/categories/back-end/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://haohaio.github.io/tags/spring/"}]},{"title":"Git 常用命令","slug":"Git常用命令","date":"2018-12-15T12:03:21.000Z","updated":"2018-12-17T07:37:50.616Z","comments":true,"path":"others/git-common-commands-1544875401.html","link":"","permalink":"https://haohaio.github.io/others/git-common-commands-1544875401.html","excerpt":"","text":"配置# 配置git的全局账号$ git config --global user.name \"username\"# 配置git的全局账号邮箱$ git config --global user.email \"email\"# 查看配置的结果$ git config --global -l 仓库# 新建本地仓库$ git init# 克隆远程仓库$ git clone url (gcl)# 查看所有远程仓库信息$ git remote -v# 添加远程仓库$ git remote add name url# 删除远程仓库$ git remote remove name 基本命令 git add # 提交所有Working Dir修改到Index$ git add .# 提交所有Working Dir中dir目录/file文件的修改到Index$ git add dir/file # \"git add .\" 和 \"git add -A\" 的区别?# stages new and modified, without deleted$ git add .# stages all$ git add -A git commit # 提交所有Index修改到HEAD，并附上 commit message$ git commit -m# 提交所有修改到HEAD(包含Working Dir和Index，但不包含new files)，并附上 commit message$ git commit -a -m (gcam)# 修订HEAD的修改$ git commit --amend git push # 提交本地仓库修改至Remote仓库的master分支$ git push origin master git reset # 从Index中恢复所有修改$ git reset# 恢复到HEAD的上一次提交$ git reset HEAD^(HEAD~1) git checkout # 撤销相应的文件修改$ git checkout file(dir)# 检出某一commit ID的修改$ git checkout d928a3 git clean # 删除untracked files$ git clean -f# 连 untracked 的目录也一起删掉$ git clean -fd# 查看哪些文件会被删除$ git clean -nfd git diff # 查看Working Dir与Index的区别$ git diff# 查看Index与HEAD的区别$ git diff –-cached# 查看Working Dir与HEAD的区别$ git diff HEAD git log # 显示 commit log$ git log# 显示代码差异$ git log -p# 概要显示$ git log --stat# 单行显示$ git log --pretty=oneline# 显示最近3条提交$ git log -3# 显示最近24h的提交$ git log --since=\"24 hours\"# 显示某file文件修改的记录$ git log file# 通过信息检索提交$ git log --grep=\"fixbug\"# 通过作者检索提交$ git log --author=\"yuanfang\" git reflog 会记录所有HEAD的历史，也就是说当你做 reset，checkout等操作的时候，这些操作会被记录在reflog中。 git fsck –lost-found 查看“丢失的”对象们，比如因reset而看不到的commit git show # 查看HEAD的所有代码改动$ git show# 查看某一commit ID的所有代码改动$ git show d928a3 git blame # 查看file文件每一行的最近一次修改的信息 $ git blame file# 查看file文件50行至60行的最近一次修改的信息$ git blame -L 50,60 file git stash # 将修改暂存入栈$ git stash# 恢复栈顶的修改$ git stash pop# 列出栈中所有修改$ git stash list# 列出栈中所有修改的代码详情$ git stash list -p# 恢复栈中指定修改$ git stash apply stash@&#123;1&#125;# 清空栈$ git stash clear# 删除栈中修改$ git stash drop stash@&#123;1&#125; 分支 git branch # 列出本地已经存在的分支$ git branch# 列出远程分支$ git branch -r# 列出本地分支和远程分支$ git branch -a# 创建新的分支new_branch$ git branch new_branch# 切换到分支new_branch$ git checkout new_branch# 删除分支new_branch$ git branch -d new_branch# 推送new_branch到Remote仓库$ git push origin new_branch# 删除Remote仓库new_branch$ git push origin :new_branch git merge &amp; git rebase &amp; git cherry-pick # 合并master到当前分支$ git merge master# 变基当前分支到master$ git rebase master# 合并某个commit到当前分支$ git cherry-pick commit-id 标签# 列出本地已经存在的标签$ git tag# 创建新的标签new_tag$ git tag new_tag# 删除标签new_tag$ git tag -d new_tag # 推送new_tag到Remote仓库$ git push origin new_tag# 推送所有标签到Remote仓库$ git push origin --tags# 删除Remote仓库new_tag$ git push origin -d tag new_tag$ git push origin :refs/tags/new_tag# 获取Remote仓库所有的标签$ git fetch origin 补丁# 将修改写入到patch文件 .patch$ git diff &gt; .patch# 将.patch的修改恢复到当前git工程$ patch -p1 &lt; .patch .gitignore 配置规则 *.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt .gitignore文件发现却没有生效时（ .gitignore只能忽略那些原来没有被track的文件） $ git rm -r --cached .$ git add .$ git commit -m 'update .gitignore' 统计某人提交代码的次数 $ git log --pretty=oneline --author='username' | wc -l","categories":[{"name":"其它","slug":"others","permalink":"https://haohaio.github.io/categories/others/"}],"tags":[{"name":"Git","slug":"git","permalink":"https://haohaio.github.io/tags/git/"}]},{"title":"Canvas学习笔记一：初识Canvas","slug":"初识Canvas","date":"2018-12-13T11:51:53.000Z","updated":"2018-12-29T06:23:22.409Z","comments":true,"path":"front-end/canvas-1-1544701913.html","link":"","permalink":"https://haohaio.github.io/front-end/canvas-1-1544701913.html","excerpt":"","text":"简介canvas 元素可以说是 HTML5 元素中功能最强大的一个。我们可以通过 canvas 元素来绘制图像，不过 canvas 本身并没有绘制能力，必须通过js脚本来完成实际的绘制任务。canvas的能力主要是通过 canvas 的 context 对象表现出来的，该对象提供了用于在画布上绘图的方法和属性。 可以先看一个简单的 demo Hello Canvas，来简单了解一下canvas。 context 对象的获取var canvas = getElementById('canvas');// '2d' 中的 'd' 必须小写var context = canvas.getContext('2d'); canvas 的 “后备内容” (fallback content) IE8 以及更早的版本不支持 canvas 元素。 当浏览器不支持 canvas 元素时，canvas 元素内部部分所含的文本就会显示出来，这种文本叫做“后备内容” (fallback content)。 &lt;canvas&gt; Canvas not supported&lt;/canvas&gt; 另外我们可以通过简单的 js 代码来检查浏览器对 canvas 的支持性： var canvas = document.getElementById('canvas');if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); // drawing code here&#125; else &#123; // canvas-unsupported code here&#125; canvas 的尺寸默认的canvas元素大小是 300 * 150 个像素。 我们可以通过指定 width 和 height 属性值来修改 canvas 元素的大小。 &lt;canvas id=\"canvas\" width=\"600\" height=\"300\"&gt; 在设置 canvas 的宽度和高度时，不能使用 px 后缀。虽说支持 canvas 的浏览器普遍都允许使用 px 后缀，但是这是不被 canvas 规范所接受的。根据规范，这些属性的取值，只能是非负整数。 canvas 元素的大小和绘图表面的大小我们还可以通过 CSS 属性来改变 canvas 元素的大小。 #canvas &#123; width: 600px; height: 300px;&#125; 不过通过 CSS 设置 canvas 元素的大小，与通过 width、height 属性值设定，效果并不一样。 其根本原因是因为 canvas 元素实际上有两套尺寸。一个是元素本身的大小，还有一个是元素绘图表面（drawing surface）的大小。 当设置元素的 width 和 height 属性时，实际上是同时修改了元素本身的大小和元素绘图表面的大小。然而，通过 CSS 来设定 canvas 元素的大小时，只会改变元素本身的大小，而不会影响到绘图表面。当 canvas 元素的大小不符合起绘图表面的大小时，浏览器就会对绘图表面进行缩放，使其符合元素的大小。具体效果如如下面两幅图所示： 通过设置元素的 width 和 height 属性修改 canvas 元素大小的效果 通过 CSS 来设定 canvas 元素的大小的效果 （浏览器自动缩放） 所以一般情况下我们都是通过 width 与 height 属性而非 CSS 来修改 canvas 元素的大小。 canvas 元素的 APIcanvas 元素只提供了2个属性与3个方法。 canvas元素的属性 属性 类型 默认值 width 非负整数 300 height 非负整数 150 canvas元素的方法 方法 描述 getContext() 返回与该 canvas 元素相关的绘图环境对象。 toDataURL(type, encoderOptions) 返回一个数据地址（data URL），可将其设定为 img 元素的 src 属性值。第一个参数指定了图像的类型，例如 image/jpeg 或 image/png，默认为 image/png。第二个参数在指定图片格式为 image/jpeg 或 image/webp的情况下, 可设定为 0 ~ 1.0 之间的 double 值，表示 JPEG 图像的显示质量，如果超出取值范围，将会使用默认值 0.92。 toBlob(callback, type, encoderOptions) 创建一个用于表示次canvas 元素图像文件的 Blob。第一个参数是一个回调函数，并传入一个 blob 对象作为参数，第二个参数为图像类型，最后一个参数为 JPEG 图像的显示质量","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Web动画之animation","slug":"Web动画之animation","date":"2018-12-12T01:40:21.000Z","updated":"2018-12-17T07:35:47.551Z","comments":true,"path":"front-end/web-animation-animation-1544578821.html","link":"","permalink":"https://haohaio.github.io/front-end/web-animation-animation-1544578821.html","excerpt":"","text":"在 Web动画之transition 中我们可以了解到 transition 可以把一系列属性从一个状态变到另一个状态。CSS动画还提供了一种创建动画的方式，而且功能更加丰富。animation 能把一系列属性从一个状态变到另一个状态，再变到第三个状态，然后一直这么变下去。此外，还能重播动画，鼠标移到动画上时停止动画，甚至在动画结束时还能倒播动画。接下来我们就来了解一下 animation。 animation 比 transition 复杂一些，不过有个额外的好处：无需触发就能开始动画。 Animation 简介 与 transition 一样，IE9 及之前的版本也不支持 animation。 创建 animation 的过程主要分成以下两步： 定义动画即设置 keyframe (关键帧, 指展示画面的一帧)，列出要变化的CSS属性。基本结构如下： @keyframes animationName &#123; from &#123; /* 在这里列出CSS属性 */ &#125; to &#123; /* 在这里列出CSS属性 */ &#125;&#125; keyframes 不是CSS属性，而是@规则。此外，CSS还有几个@规则：在样式表中加载另外一个样式表的 @import 语句；为不同媒介类型定义样式的 @media。 首先在 @keyframes 后面定义一个名称，即动画的名称 (e.g. fadeIn、fadeOut)。 然后至少添加两个关键帧。在上面的示例中，关键字 from 用于创建起始关键帧，关键字 to 用于创建结束关键帧。在每个关键帧中可以添加一个或多个CSS属性，与定义样式一样。例如： fadeIn 不仅只能定义两个关键帧，还可以用百分比值定义多个关键帧。百分比表示在整个动画过程的什么位置发生变化。 例如：growAndGlow 百分比值的用法还有个特别的技巧：使用不同的百分比值定义相同的CSS属性。首先，当动画播放到摸一会时刻时暂停，然后再继续 (e.g. glow)。还可以用来不同时间段使用相同的CSS属性(e.g. glow) 可以把关键字 form 换成 0%，把关键字 to 换成 100%。 应用动画定义好动画后，若想播放动画，还需将动画应用到页面的元素上。 直接将动画加到动画的样式中，则动画在页面加载时就会播放(上面的例子都是如此)。 此外，可以把动画添加到某个伪类中 (e.g. :hover、:active、:target或:focus)，还可以把动画添加到类样式中，在需要的时候使用js动态应用那个类样式。 CSS提供了几个 animation 相关的属性，用于控制如何以及何时播放动画。 有些属性与 transition 基本相同，这里不做过多解释 animation-name 以CSS关键字做动画名称时，放在引号里能避免冲突 可以对应多个动画的名称，来让一个元素应用多个动画 animation-duration animation-timing-function 可以为每个关键帧设置不同的时序函数 animation-dealy animation-iteration-count (动画运行次数)(e.g. animation-iteration-count: 10;) 设为关键字 infinite 时，可无限次运行动画 animation-direction 当动画多次执行时，如有需要，可设为 alternate 关键字，动画会在奇数时正向播放，偶数时反向播放。 animation-fill-mode 可设为 forwords 关键字，当动画结束时让元素显示成动画结束后的样子。 animation属性的简写形式 名字和持续时间是必写的。 多个动画时，可用逗号分开。 暂停动画若有需要可使用伪类或js设置 animation-play-state (running|paused) 属性为 paused 来暂停动画。 推荐推荐一个CSS animation库 animate.css，这个库封装了很多动画，拿来即用，非常方便。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]},{"title":"Web动画之transition","slug":"Web动画之transition","date":"2018-12-09T06:28:26.000Z","updated":"2018-12-17T07:35:45.995Z","comments":true,"path":"front-end/web-animation-transition-1544336906.html","link":"","permalink":"https://haohaio.github.io/front-end/web-animation-transition-1544336906.html","excerpt":"","text":"目前Web动画主要有两大实现途径： CSS3动画。这类动画是当前页面动画的主力军，主要通过 transition 和 animation 两种方式来实现。 transition (过渡) 一种简单的动画，在一定时间内从一组CSS\b属性变成另一组属性。 animation 是关键帧动画，可以预先为动画设置多个节点，在每个节点中含有不同的状态属性，通过使用 animation 我们可以得到更为复杂的动画效果。 JavaScript动画。这类动画是通过JavaScript来动态的控制并刷新元素的各个属性值，以形成动画效果。 除以上两者外，我们也可以使用SVG 或 canvas等来制作动画。 一般来说，大部分简单的动画都可以使用 transition 实现。JavaScript动画则往往用于更加复杂，或是需要结合各类用户交互操作的动画效果。在运行效率方面，像jQuery这种JavaScript类库的动画效果要低于CSS3动画。而在兼容性方面，CSS3动画的兼容性要差于jQuery等类库动画，前者并不支持IE9之前的浏览器。今天就先了解一下 transition 动画。 Transition简介一种简单的动画，在一定时间内从一组CSS\b属性变成另一组属性。 IE只有10和以后的版本才支持transition 为了实现过渡效果，要满足以下几个条件： 两个样式 (过渡前的样式和过渡\b后的样式) transition\b属性 (\b\b添加到初始样式中) 触发器 (指促使元素在两个在两个元素之间变化的操作。在CSS中可以使用伪类触发动画 (e.g. :hover、:active、:target或:focus)，还可以使用js触发 (增删类或者修改属性)) transition 的四个属性 transition-property (指定需要变化的属性，\b可用关键字all表示所有属性) transition-property: color, background-color;transition-property: all; transition-duration (动画持续时间) transition-duration: .5s;transition-duration: 500ms; transition-timing-function (过渡的时序，即持续过程的速率) linear (中间快，两头慢) ease (\b开始时慢，中间加速，\b末尾又降速)default ease-in \b(开始时慢，之后快) ease-out \b(开始时快，结束时候慢) ease-in-out (两头慢) 可通过演示具体比较一下\b\b各个速率的区别 演示地址 transition-delay (动画\b延时时间) transition属性的简写形式 要变化的属性和动画的持续时间是必写的。默认情况下，时序函数是ease，而且没有延迟。 多个要变化的属性时，可用逗号分开。 transition: all 1s;transition: background-color 1s, color .5s, border-color .5s 1s; 附上一个综合版的Demo transition demo 让动画更流畅以动画形式改变多个属性会增加Web浏览器的负担。一次有太多动画可能导致浏览器假死，甚至是崩溃。尤其是移动设备和平板电脑，因为这些设备的CPU比桌面电脑和笔记本电脑慢很多。 不过，有4种变化导致浏览器使用太多CPU：opacity，以及transform属性的translate、scale和rotate函数。这四个属性处理起来比其它CSS属性省事，所以它们的动画效果更流畅。 此外，还可以强制让电脑的GPU (Graphic Processing Unit, 图形处理器) 渲染动画。GPU的运算速度特别快，与电脑的CPU相比，执行特定类型的计算速度快得多。我们可以在样式中添加3D变形属性，以此“骗过”浏览器，让它使用GPU处理样式变化。但是因为GPU的处理能力有限，如果把太多视觉效果交给它处理，可能会拖慢浏览器，导致假死。","categories":[{"name":"前端","slug":"front-end","permalink":"https://haohaio.github.io/categories/front-end/"}],"tags":[{"name":"CSS","slug":"css","permalink":"https://haohaio.github.io/tags/css/"}]}]}